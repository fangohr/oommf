/* FILE: imports.cc              -*-Mode: c++-*-
 *
 *	Replacement implementations for missing Tcl/Tk APIs
 * in old Tcl/Tk releases.
 *
 * Last modified on: $Date: 2015/07/17 22:45:44 $
 * Last modified by: $Author: donahue $
 */

/* Standard libraries */
#include <cstring>
#include <cerrno>
#include <cfloat>
#include <limits>  // For std::numeric_limits<T>::max()/min()

/* Other classes and functions in this extension.  In particular,
 * imports.h includes ocport.h, which defined the OC_TCL_TYPE
 * macro referenced below.
 */
#include "oc.h"

/* Cygwin-specific routines */
#if OC_TCL_TYPE==OC_WINDOWS && defined(__CYGWIN__)
# include <unistd.h>
# include <sys/cygwin.h>
# define WIN32_LEAN_AND_MEAN
# include <windows.h>
# undef WIN32_LEAN_AND_MEAN
#endif


OC_USE_STD_NAMESPACE;  // Specify std namespace, if supported.
/// This insures standard math functions like floor, ceil, sqrt
/// are available.

/* End includes */

//////////////////////////////////////////////////////////////////////////
// Random number generator routines.  The Oc_Random class (with
// Oc_RandomState helper) is an implementation of the GLIBC random()
// function.  This class provides the default functionality of the
// OMF_RANDOM macro declared in ocport.h
//    The Oc_UnifRand() function returns a random value in [0,1] with
// unif. distrib.  It is a wrapper for OMF_RANDOM.  It may be
// (re)initialized by calling Oc_Srand() or Oc_Srand(seed).  In the
// first case the seed is determined by sampling the system clock.
//
// NOTE: The Oc_Random generator state (of type Oc_RandomState) is
// stored in a static variable.  This means that the state is shared
// program-wide, across threads.  Mutexes protect against re-entrancy
// problems, but if multiple threads access Oc_Random then the results
// can vary from run-to-run, depending on the relative access order
// between threads.
//
////////////////////////////////////////////////////////////////////////////
//
// The following a description of this algorithm by Peter Selinger,
// Department of Mathematics and Statistics, Dalhousie University,
// <selinger@mathstat.dal.ca> retrieved from
//    https://www.mscs.dal.ca/~selinger/random/ on 7-Mar-2023:
//
// *The GLIBC random number generator*
//
// Written Jan 4, 2007.
//
// The GNU C library's random() function provides pseudo-random numbers via a
// linear additive feedback method. A description of the exact algorithm used
// is hard to find, so I have documented it here.
//
// The random(3) man page states, misleadingly, that "the random() function
// uses a non-linear additive feedback random number generator". This is not
// actually true, as the feedback is in fact linear modulo 2^32. The only
// slight non-linearity is introduced during the seeding stage, due to the
// fact that the seeding calculation is done modulo 2^31 - 1 and not modulo
// 2^31 or 2^32. This means that, although each generated random number
// depends linearly on previous numbers in the sequence, the random numbers
// as a whole do not depend linearly on the seed.
//
// *Description of the algorithm*
// For reference, and because it is easier to read than source code, here
// is a mathematical description of the exact algorithm used by the GLIBC
// pseudo-random number generator. Note, in the following description, that
// 2147483647 = 2^31 - 1 and 4294967296 = 2^32. All quantities are
// mathematical integers.
//
// For a given seed s, an initialization vector r_0...r_33 is calculated
// according to the following scheme:
//
//  (1) r_0 = s
//  (2) r_i = (16807 * (signed int)r_(i-1)) mod 2147483647 (for i = 1...30)
//  (3) r_i = r_(i-31) (for i = 31...33)
//
// Note that the multiplication by 16807 is done in a large enough signed
// integer type so that there is no overflow before the modulo operation.
// Also note that r_(i-1) is converted to a signed 32-bit value before the
// multiplication, but the only time this value can be negative is in the
// case of i=1, if s ≥ 2^31. The modulo operation is mathematical, i.e.,
// the result is taken between 0 and 2147483646, even if r_(i-1) is
// negative.
//
// Then a sequence of pseudo-random numbers r_34... is generated by a
// linear feedback loop as follows:
//
//   (4) r_i = (r_(i-3) + r_(i-31)) mod 4294967296 (for i ≥ 34)
//
// r_0...r_343 are thrown away. The ith output oi of rand() is
//
//   (5) o_i = r_(i+344) >> 1
//
// Note that this is a 31-bit number; the least significant bit of
// r_(i+344) is thrown away.
//
// *Linearity*
// Despite the fact that the least significant bit is thrown away, we still
// have almost-linearity of the output sequence. As a consequence of
// equations (4) and (5), we have
//
//   (6) o_i = o_(i-31) + o_(i-3) mod 2^31 or
//       o_i = o_(i-31) + o_(i-3) + 1 mod 2^31, for all i ≥ 31.
//
// ...
//
// Note: the GLIBC implementation allows other degrees besides 31 in the
// linear feedback register, via the initstate() function. An analogous
// description applies in these situations.
//
////////////////////////////////////////////////////////////////////////////

void Oc_RandomState::Init(OC_UINT4m seed)
{
  int i;

  if(seed==0) seed=1; // Hack, to match glibc behavior.
  arr[0] = seed;
  ihead = 0;

  const OC_UINT4m MOD  = 0x7FFFFFFF;
  const OC_UINT4m MULT = 16807;

  for(i=1;i<SIZE-1;++i) {
    /* Note 1: If a<MOD and b<MOD, then a+b will fit inside
     *         an unsigned 4-byte int without overflow, because
     *         MOD < 2^31.
     * Note 2: If c<2^16, then c*MULT<MOD.
     * Note 3: 2^16 * 2^16 = 2^32 = 2*MOD + 2.  Hence,
     *         (d*2^32)%MOD = (d*2)%MOD.
     */
    OC_UINT4m rl = ((arr[i-1]) & 0xFFFF) * MULT;
    OC_UINT4m rh = ((arr[i-1]) >> 16) * MULT;

    OC_UINT4m accum = (rh & 0xFFFF) << 16;
    if(accum >= MOD) accum -= MOD;
    accum += rl;
    if(accum >= MOD) accum -= MOD;
    accum += (rh >> 16) * 2 ;

    if(accum >= MOD) accum -= MOD;
    arr[i] = accum;
  }
  for(i=SIZE-1;i<SIZE-1+SEP;++i) arr[i] = arr[i-(SIZE-1)];
  for(i=0;i<WARMUP;++i) Step();
}

void Oc_RandomState::Init()
{ // Initialize with a clock-based seed. (Uses C++-11 api).
  uint64_t seed
    = std::chrono::high_resolution_clock::now().time_since_epoch().count();
  Init(static_cast<unsigned int>(seed));
}


OC_UINT4m Oc_RandomState::Step()
{ // Max return value is 0xFFFFFFFF
  int ia = ihead - SEP;      if(ia<0) ia += SIZE-1+SEP;
  int ib = ihead - (SIZE-1); if(ib<0) ib += SIZE-1+SEP;
  OC_UINT4m rnext = arr[ihead] = (arr[ia] + arr[ib]) & 0xFFFFFFFF;

  /// Portability warnings:
  ///   1) If OC_UINT4m is 32-bits (4 bytes), then arr[ia] + arr[ib]
  ///      may overflow.  This code assumes that in all cases the
  ///      lowest 32 bits are correct, and that higher bits, if
  ///      any, are dropped.  Indeed, the final '& 0xFFFFFFFF'
  ///      is a nop if sizeof(OC_UINT4m) is 4, and is only there to
  ///      handle the case where OC_UINT4m is bigger than 4 bytes.
  ///   2) On some architectures (e.g. DEC Alpha), 4-byte unsigned
  ///      arithmetic is slower than 4 or 8 byte signed or 8 byte
  ///      unsigned.  The arr type may be changed (without affecting
  ///      the results) to 8 byte signed or unsigned, or to 4 byte
  ///      signed if the signed arithmetic is handled via two's
  ///      complement arithmetic.

  if(++ihead>=SIZE-1+SEP) ihead = 0;

  return rnext;
}

Oc_RandomState Oc_Random::state;
#if OOMMF_THREADS
std::mutex Oc_Random::random_state_mutex;  // Thread-safe hack.
#endif

void Oc_Srand(unsigned int seed)
{
  const int exercise=100;
  OMF_SRANDOM(seed+1); // On linux systems (others?), srandom(0) and
  /// srandom(1) generate the same sequence.  This is a) dumb, and
  /// b) isn't documented in the man pages.  Since 0 and 1 are likely
  /// to be common requests, work around this unexpected behavior by
  /// bumping all seeds up one.  BTW, on linux systems, srand/rand
  /// are the same as srandom/random.
  for(int i=0;i<exercise;i++) {
    OMF_RANDOM();  // "Exercise" generator, to keep it fit and trim.
  }
}

void Oc_Srand()
{
  unsigned int seed=0;
  Tcl_Interp* interp=Oc_GlobalInterpreter();
  if(interp==NULL) seed=42;  // No interpreter available
  else {
    Tcl_InterpState saved = Tcl_SaveInterpState(interp, TCL_OK);
    // Use Tcl 'clock clicks' command to get a seed. Mask to protect
    // against overflow (and undefined behavior) when down converting to
    // an unsigned int. (The mask assumes sizeof(unsigned int)==4.)
    Tcl_Eval(interp,"expr {[clock clicks]&0xFFFFFFFF}");
    seed=(unsigned int)strtoul(Tcl_GetStringResult(interp),0,0);
    Tcl_RestoreInterpState(interp, saved);
  }
  Oc_Srand(seed);
}

double Oc_UnifRand()
{ // Returns random value in [0,1] with unif. distrib.
  return ((double)OMF_RANDOM())/((double)OMF_RANDOM_MAX);
}

double Oc_UnifRand(Oc_RandomState& mystate)
{ // Returns random value in [0,1] with unif. distrib.  Note: Unlike
  // Oc_UnifRand(), this routine does not use OMF_RANDOM wrappers.  This
  // means that this routine can not be overridden by a user-specified
  // random number generator.
  return ((double)Oc_Random::Random(mystate))/((double)Oc_Random::MaxValue());
}


// Tcl wrappers for Oc_Srand and Oc_UnifRand
int OcSrand(ClientData,Tcl_Interp *interp,int argc, const char** argv)
{
  char buf[256];
  Tcl_ResetResult(interp);
  if(argc>2) {
    Oc_Snprintf(buf,sizeof(buf),
		"wrong # args: should be \"%.100s ?arg?\"",argv[0]);
    Tcl_AppendResult(interp,buf,(char *)NULL);
    return TCL_ERROR;
  }

  if(argc<2) {
    Oc_Srand(); // Use clock-based seed
  } else {
    char* endptr;
    unsigned long int ulseed = strtoul(argv[1],&endptr,10);
    if(argv[1][0]=='\0' || *endptr!='\0') {
      // argv[1] is not an integer
      Oc_Snprintf(buf,sizeof(buf),
		  "bad seed \"%.100s\": must be integer",argv[1]);
      Tcl_AppendResult(interp,buf,(char *)NULL);
      return TCL_ERROR;
    }
    Oc_Srand(static_cast<unsigned int>(ulseed));
  }

  return TCL_OK;
}

int OcUnifRand(ClientData,Tcl_Interp *interp,int argc, const char** argv)
{
  static char buf[256];
  Tcl_ResetResult(interp);
  if(argc!=1) {
    Oc_Snprintf(buf,sizeof(buf),
		"wrong # args: should be \"%.100s\"",argv[0]);
    Tcl_AppendResult(interp,buf,(char *)NULL);
    return TCL_ERROR;
  }
  Oc_Snprintf(buf,sizeof(buf),"%.17g",Oc_UnifRand());
  Tcl_AppendResult(interp,buf,(char *)NULL);

  return TCL_OK;
}

int OcReadRNGState
(ClientData,Tcl_Interp *interp,int argc, const char** argv)
{
  char buf[1024];
  Tcl_ResetResult(interp);
  if(argc!=1) {
    Oc_Snprintf(buf,sizeof(buf),
		"wrong # args: should be \"%.100s\"",argv[0]);
    Tcl_AppendResult(interp,buf,(char *)NULL);
    return TCL_ERROR;
  }
  if(!Oc_Random::ReadRNGState(buf,sizeof(buf))) {
    Tcl_AppendResult(interp,"Internal buffer too short",(char *)NULL);
    return TCL_ERROR;
  }
  Tcl_AppendResult(interp,buf,(char *)NULL);
  return TCL_OK;
}


////////////////////////////////////////////////////////////////////////
// C++ library-based random number generators. Requires C++11.
// Static instances of Oc_RandomClib and support wrappers, intended for
// use from Tcl. C++ code should create and use local instantiations.
//
// NB: The C++11 specs dictate that the standard (i.e., std::) prng
//     provide, for a given seed, identical sequences independent of
//     implementation. However, the distributions are allowed to be
//     implementation dependent.  In particular, the GNU C++ and
//     Visual C++ normal distribution implementations produce sequences
//     with each pair swapped, i.e., if GNU C++ produces
//        a1 a2 a3 a4 a5 a6 ...
//     then Visual C++ gives
//        a2 a1 a4 a3 a6 a5 ...

namespace {
  Oc_RandomClib<std::uniform_real_distribution,double> clibuniformrv;
  Oc_RandomClib<std::normal_distribution,double> clibnormalrv;
#if OOMMF_THREADS
  std::mutex clib_uniform_rng_mutex; // Thread-safe hack.
  std::mutex clib_normal_rng_mutex;  // Thread-safe hack.
#endif
}

void Oc_SeedRV()
{
  {
#if OOMMF_THREADS
    std::lock_guard<std::mutex> lck(clib_uniform_rng_mutex);
#endif // OOMMF_THREADS
    clibuniformrv.Seed();
  }
  {
#if OOMMF_THREADS
    std::lock_guard<std::mutex> lck(clib_normal_rng_mutex);
#endif // OOMMF_THREADS
    clibnormalrv.Seed();
  }
}

void Oc_SeedRV(unsigned int seed)
{
  {
#if OOMMF_THREADS
    std::lock_guard<std::mutex> lck(clib_uniform_rng_mutex);
#endif // OOMMF_THREADS
    clibuniformrv.Seed(seed);
  }
  {
#if OOMMF_THREADS
    std::lock_guard<std::mutex> lck(clib_normal_rng_mutex);
#endif // OOMMF_THREADS
    clibnormalrv.Seed(seed);
  }
}

double Oc_UniformRV()
{
#if OOMMF_THREADS
  std::lock_guard<std::mutex> lck(clib_uniform_rng_mutex);
#endif // OOMMF_THREADS
  return clibuniformrv();
}

double Oc_NormalRV()
{
#if OOMMF_THREADS
  std::lock_guard<std::mutex> lck(clib_normal_rng_mutex);
#endif // OOMMF_THREADS
  return clibnormalrv();
}


// Tcl wrappers for global C++ library based RNGs
int OcSeedRV(ClientData,Tcl_Interp *interp,int argc, const char** argv)
{
  char buf[256];
  Tcl_ResetResult(interp);
  if(argc>2) {
    Oc_Snprintf(buf,sizeof(buf),
		"wrong # args: should be \"%.100s ?arg?\"",argv[0]);
    Tcl_AppendResult(interp,buf,(char *)NULL);
    return TCL_ERROR;
  }

  if(argc<2) {
    Oc_SeedRV();
  } else {
    char* endptr;
    unsigned long int ulseed = strtoul(argv[1],&endptr,10);
    if(argv[1][0]=='\0' || *endptr!='\0') {
      // argv[1] is not an integer
      Oc_Snprintf(buf,sizeof(buf),
		  "bad seed \"%.100s\": must be integer",argv[1]);
      Tcl_AppendResult(interp,buf,(char *)NULL);
      return TCL_ERROR;
    }
    unsigned int seed = static_cast<unsigned int>(ulseed);
    Oc_SeedRV(seed);
  }
  return TCL_OK;
}

int OcUniformRV(ClientData,Tcl_Interp *interp,int argc, const char** argv)
{
  static char buf[256];
  Tcl_ResetResult(interp);
  if(argc!=1) {
    Oc_Snprintf(buf,sizeof(buf),
		"wrong # args: should be \"%.100s\"",argv[0]);
    Tcl_AppendResult(interp,buf,(char *)NULL);
    return TCL_ERROR;
  }
  Oc_Snprintf(buf,sizeof(buf),"%.17g",Oc_UniformRV());
  Tcl_AppendResult(interp,buf,(char *)NULL);
  return TCL_OK;
}

int OcNormalRV(ClientData,Tcl_Interp *interp,int argc, const char** argv)
{
  static char buf[256];
  Tcl_ResetResult(interp);
  if(argc!=1) {
    Oc_Snprintf(buf,sizeof(buf),
		"wrong # args: should be \"%.100s\"",argv[0]);
    Tcl_AppendResult(interp,buf,(char *)NULL);
    return TCL_ERROR;
  }
  Oc_Snprintf(buf,sizeof(buf),"%.17g",Oc_NormalRV());
  Tcl_AppendResult(interp,buf,(char *)NULL);
  return TCL_OK;
}


//////////////////////////////////////////////////////////////////////////
// Tcl wrapper for Oc_Atan2
int OcAtan2(ClientData, Tcl_Interp *interp,
            int argc, const char** argv)
{
  static char buf[256];
  Tcl_ResetResult(interp);
  if(argc!=3) {
    Oc_Snprintf(buf,sizeof(buf),
		"wrong # args: should be \"%.100s y x\"",argv[0]);
    Tcl_AppendResult(interp,buf,(char *)NULL);
    return TCL_ERROR;
  }
  errno = 0;
  double y = atof(argv[1]);
  double x = atof(argv[2]);
  double result = Oc_Atan2(y,x);
  if (errno != 0) {
    Tcl_ResetResult(interp);
    Tcl_AppendResult(interp,"errno set to ",NULL);
    switch (errno) {
    case ERANGE:
      Tcl_AppendResult(interp,"ERANGE",NULL);
      break;
    case EDOM:
      Tcl_AppendResult(interp,"EDOM",NULL);
      break;
    default:
      Tcl_AppendResult(interp,"unexpected value",NULL);
      break;
    }
    Tcl_AppendResult(interp," by atan2()",NULL);
    return TCL_ERROR;
  }

  Oc_Snprintf(buf,sizeof(buf),"%.17g",result);
  Tcl_AppendResult(interp,buf,(char *)NULL);

  return TCL_OK;
}

//////////////////////////////////////////////////////////////////////////
// Utility filesystem command
//  Oc_FSync mimics the unix fysnc() or Windows _commit()/FlushFileBuffers()
// routines, which force data buffered by the OS to disk.  Note that this
// code may block, so only call when necessary.
// The return value is 0 on success, -1 on error.
int Oc_Fsync(Tcl_Channel chan)
{
  int errcode = 0;
  Tcl_Flush(chan);
  ClientData cd;
  if(Tcl_GetChannelHandle(chan,TCL_WRITABLE,&cd)!=TCL_OK) {
    return -1;
  }

#if OC_SYSTEM_TYPE==OC_UNIX
  // The FileGetHandleProc routine in tclUnixChan.c passes the (int)
  // file descriptor through client data via the Tcl INT2PTR macro.
  // Presumably the proper way to cast back from client data to an int
  // is through a signed int with width >= pointer width.  (It would be
  // nice for Tcl to provide an interface for this.)
  int handle = reinterpret_cast<OC_INDEX>(cd);
  errcode = fsync(handle);

#elif OC_SYSTEM_TYPE==OC_WINDOWS
  // The FileGetHandleProc routine in tclWinChan.c passes the file
  // descriptor (of type HANDLE) by casting from HANDLE directly to
  // ClientData.  So we should be able to cast directly back.  (Both
  // ClientData and HANDLE are, under the hood, void*.)
  HANDLE handle  = reinterpret_cast<HANDLE>(cd);
  errcode = !(FlushFileBuffers(handle));

#endif // OC_SYSTEM_TYPE

  return ( errcode == 0 ? 0 : -1 );
}

//////////////////////////////////////////////////////////////////////////
// Utility function for computing polynomials of order N
double Oc_Polynomial(double x, const double *coef, unsigned int N) {
    double ans = *coef++;
    while (N--) {
	ans = ans * x + *coef++;
    }
    return ans;
}

// Fallback implementation for those systems where the math
// library fails to provide an erf() function.  On those
// systems a macro in ocport.h will #define erf(x) to be Oc_Erf((x)).
//
// This implementation is one provided by Abdullah Daoud which has
// been passed down in the Institute for Magnetics Research at GWU.
// We should replace it with an implementation from GAMS with known
// numeric properties when we have time.
double Oc_Erf(double x)
{
    const double A[] = {
	 1.061405429,
	-1.453152027,
	 1.421413714,
	-0.284496736,
	 0.254829592,
	 0.0
    };
    const double p	= 0.3275911;
    double t		= 1.0 / (1.0 + p*fabs(x));
    double erfx = 1.0 - exp(-x*x) * Oc_Polynomial(t, A, 5);
    if (x>0) {
        return erfx;
    } else {
        return -erfx;
    }
}

//////////////////////////////////////////////////////////////////
// Version of chdir for use when using the cygwin libraries.  The
// problem arises when a Windows version of Tcl/Tk is used in the
// cygwin environment to build and run OOMMF.  (This is done because
// the cygwin-specific version of tclsh 8.4.1 has broken socket
// handling.)  In this circumstance a 'cd' command at the Tcl script
// level changes the Tcl and Windows view of the current working
// directory (cwd), but not the cygwin view of the cwd.  This leads to
// problems if a later call is made through the cygwin library to
// access a file via a path relative to the cwd.
//   This code is based on code from the Windows-specific branch
// of the Tcl sources.
#if OC_TCL_TYPE==OC_WINDOWS && defined(__CYGWIN__)
int OcCygwinChDir(ClientData,Tcl_Interp *interp,
                  int argc, const char** argv)
{
  char buf[4096+MAX_PATH+1];
  Tcl_ResetResult(interp);
  if(argc!=2) {
    Oc_Snprintf(buf,sizeof(buf),
		"wrong # args: should be \"%.500s ?dirName?\"",argv[0]);
    Tcl_AppendResult(interp,buf,(char *)NULL);
    return TCL_ERROR;
  }

  Tcl_Obj* pathobj = Tcl_NewStringObj(argv[1],-1);
  Tcl_IncrRefCount(pathobj);
  Tcl_DString ds;
  const TCHAR *natpath = (const TCHAR *) Tcl_FSGetNativePath(pathobj);
  cygwin_conv_to_posix_path(Tcl_WinTCharToUtf(natpath,-1,&ds),buf);
  Tcl_DStringFree(&ds);
  Tcl_DecrRefCount(pathobj);
  pathobj = NULL; // Safety

  if(chdir(buf)!=0) {
    // Should probably include better error reporting here.
    Oc_Snprintf(buf,sizeof(buf),
		"Unable to change working directory to \"%.500s\"",
                argv[1]);
    Tcl_AppendResult(interp,buf,(char *)NULL);
    return TCL_ERROR;
  }

  return TCL_OK;
}
#endif // OC_WINDOWS && __CYGWIN__
