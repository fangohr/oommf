<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Standard Oxs_Ext Child Classes</TITLE>
<META NAME="description" CONTENT="Standard Oxs_Ext Child Classes">
<META NAME="keywords" CONTENT="userguide">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="userguide.css">

<LINK REL="previous" HREF="OOMMF_eXtensible_Solver_Bat.html">
<LINK REL="up" HREF="OOMMF_eXtensible_Solver.html">
<LINK REL="next" HREF="Micromagnetic_Problem_Edito.html">
</HEAD>

<BODY BGCOLOR="#FFFFFF",text="#000000",LINK="#0000FF",
            VLINK="#4498F0",ALINK="00FFFF">
<!--Navigation Panel--><A NAME="tex2html1"
  HREF="http://math.nist.gov/oommf"><IMG ALT="OOMMF Home" BORDER="2" SRC="oommficon.gif"></A> 
<A NAME="tex2html357"
  HREF="Micromagnetic_Problem_Edito.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.gif"></A> 
<A NAME="tex2html353"
  HREF="OOMMF_eXtensible_Solver.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.gif"></A> 
<A NAME="tex2html349"
  HREF="OOMMF_eXtensible_Solver_Bat.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.gif"></A> 
<A NAME="tex2html359"
  HREF="userguide.html"><IMG ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.gif"></A> 
<A NAME="tex2html355"
  HREF="docindex.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.gif"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html358"
  HREF="Micromagnetic_Problem_Edito.html">Micromagnetic Problem Editor: mmProbEd</A>
<B> Up:</B> <A NAME="tex2html354"
  HREF="OOMMF_eXtensible_Solver.html">OOMMF eXtensible Solver</A>
<B> Previous:</B> <A NAME="tex2html350"
  HREF="OOMMF_eXtensible_Solver_Bat.html">OOMMF eXtensible Solver Batch</A>
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html361"
  HREF="Standard_Oxs_Ext_Child_Clas.html#SECTION00083100000000000000">Atlases</A>
<LI><A NAME="tex2html362"
  HREF="Standard_Oxs_Ext_Child_Clas.html#SECTION00083200000000000000">Meshes</A>
<LI><A NAME="tex2html363"
  HREF="Standard_Oxs_Ext_Child_Clas.html#SECTION00083300000000000000">Energies</A>
<LI><A NAME="tex2html364"
  HREF="Standard_Oxs_Ext_Child_Clas.html#SECTION00083400000000000000">Evolvers</A>
<LI><A NAME="tex2html365"
  HREF="Standard_Oxs_Ext_Child_Clas.html#SECTION00083500000000000000">Drivers</A>
<LI><A NAME="tex2html366"
  HREF="Standard_Oxs_Ext_Child_Clas.html#SECTION00083600000000000000">Field Objects</A>
<LI><A NAME="tex2html367"
  HREF="Standard_Oxs_Ext_Child_Clas.html#SECTION00083700000000000000">MIF Support Classes</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H2><A NAME="SECTION00083000000000000000"></A><A NAME="sec:oxsext"></A>
<BR>
Standard Oxs_Ext Child Classes
</H2><A NAME="4494"></A>
An Oxs simulation is built as a collection of <TT>Oxs_Ext</TT> (Oxs
Extension) objects.  These are defined via Specify blocks in the input
<A HREF="MIF_2.1.html#sec:mif2format">MIF&nbsp;2 file.</A>
The reader will find the information and
<A HREF="MIF_2.1.html#fig:mif2sample">sample MIF file</A> provided in that section to be a helpful
adjunct to the material presented below.  Addition example MIF&nbsp;2
files can be found in the directory <TT><B>oommf/app/oxs/examples</B></TT>.

<P>
This section describes the <TT>Oxs_Ext</TT> classes available in the
standard OOMMF distribution, including documentation of their Specify
block initialization strings, and a list of some sample MIF files from
the <TT><B>oommf/app/oxs/examples</B></TT> directory that use the class.  The
standard <TT>Oxs_Ext</TT> objects, i.e., those that are distributed with
OOMMF, can be identified by the <TT>Oxs_</TT> prefix in their names.
Additional <TT>Oxs_Ext</TT> classes may be available on your system.  Check
local documentation for details.

<P>
In the following presentation, the <TT>Oxs_Ext</TT> classes are organized
into 8 categories: atlases, meshes, energies, evolvers, drivers, scalar
field objects, vector field objects, and MIF support classes.  The
following <TT>Oxs_Ext</TT> classes are currently available:

<UL>
<LI>Atlases
  
<PRE>
   <A HREF="#BA">Oxs_BoxAtlas</A>                    <A HREF="#IA">Oxs_ImageAtlas</A>
   <A HREF="#MA">Oxs_MultiAtlas</A>                  <A HREF="#SA">Oxs_ScriptAtlas</A>
   <A HREF="#EA">Oxs_EllipsoidAtlas</A>
</PRE>
</LI>
<LI>Meshes
  
<PRE>
   <A HREF="#RM">Oxs_RectangularMesh</A>            <A HREF="#PRM">Oxs_PeriodicRectangularMesh</A>
</PRE>
</LI>
<LI>Energies
  
<PRE>
   <A HREF="#CA">Oxs_CubicAnisotropy</A>             <A HREF="#DE">Oxs_Demag</A>
   <A HREF="#E6">Oxs_Exchange6Ngbr</A>               <A HREF="#EP">Oxs_ExchangePtwise</A>
   <A HREF="#FZ">Oxs_FixedZeeman</A>                 <A HREF="#SE">Oxs_RandomSiteExchange</A>
   <A HREF="#SU">Oxs_ScriptUZeeman</A>               <A HREF="#SD">Oxs_SimpleDemag</A>
   <A HREF="#SZ">Oxs_StageZeeman</A>                 <A HREF="#TZ">Oxs_TransformZeeman</A>
   <A HREF="#TS">Oxs_TwoSurfaceExchange</A>          <A HREF="#UA">Oxs_UniaxialAnisotropy</A>
   <A HREF="#UE">Oxs_UniformExchange</A>             <A HREF="#UZ">Oxs_UZeeman</A>
</PRE>
</LI>
<LI>Evolvers
  
<PRE>
   <A HREF="#CG">Oxs_CGEvolve</A>                    <A HREF="#EE">Oxs_EulerEvolve</A>
   <A HREF="#RK">Oxs_RungeKuttaEvolve</A>            <A HREF="#SX">Oxs_SpinXferEvolve</A>
</PRE>
</LI>
<LI>Drivers
  
<PRE>
   <A HREF="#MD">Oxs_MinDriver</A>                  <A HREF="#TD">Oxs_TimeDriver</A>
</PRE>
</LI>
<LI>Scalar Field Objects
  
<PRE>
   <A HREF="#ASF">Oxs_AtlasScalarField</A>           <A HREF="#LSF">Oxs_LinearScalarField</A>
   <A HREF="#RSF">Oxs_RandomScalarField</A>          <A HREF="#SSF">Oxs_ScriptScalarField</A>
   <A HREF="#USF">Oxs_UniformScalarField</A>         <A HREF="#VMSF">Oxs_VecMagScalarField</A>
   <A HREF="#SOSF">Oxs_ScriptOrientScalarField</A>    <A HREF="#AOSF">Oxs_AffineOrientScalarField</A>
   <A HREF="#ATSF">Oxs_AffineTransformScalarField</A> <A HREF="#ISF">Oxs_ImageScalarField</A>
</PRE>
</LI>
<LI>Vector Field Objects
  
<PRE>
   <A HREF="#AVF">Oxs_AtlasVectorField</A>           <A HREF="#FVF">Oxs_FileVectorField</A>
   <A HREF="#PRVF">Oxs_PlaneRandomVectorField</A>     <A HREF="#RVF">Oxs_RandomVectorField</A>
   <A HREF="#SVF">Oxs_ScriptVectorField</A>          <A HREF="#UVF">Oxs_UniformVectorField</A>
   <A HREF="#SOVF">Oxs_ScriptOrientVectorField</A>    <A HREF="#AOVF">Oxs_AffineOrientVectorField</A>
   <A HREF="#ATVF">Oxs_AffineTransformVectorField</A> <A HREF="#MVF">Oxs_MaskVectorField</A>
   <A HREF="#IVF">Oxs_ImageVectorField</A>
</PRE>
</LI>
<LI>MIF Support Classes
  
<PRE>
   <A HREF="#LV">Oxs_LabelValue</A>
</PRE>
</LI>
</UL>

<P>

<H3><A NAME="SECTION00083100000000000000"></A><A NAME="sec:oxsAtlases"></A>
<BR>
Atlases
</H3>
Geometric volumes of spaces are specified in Oxs via <I>atlases</I>,
which divide their domain into one or more disjoint subsets called
<I>regions</I>.  Included in each atlas definition is the atlas
<I>bounding box</I>, which is an axes parallel rectangular
parallelepiped containing all the regions.  There is also the special
<I>universe</I> region, which consists of all points outside the
regions specified in the atlas.  The universe region is not considered
to be part of any atlas, and the <TT>universe</TT> keyword should not be
used to label any of the atlas regions.

<P>
The most commonly used atlas is the simple <TT>Oxs_BoxAtlas</TT>.  For
combining multiple atlases, use <TT>Oxs_MultiAtlas</TT>.

<P>
<DL>
<DD><A NAME="BA"></A><A NAME="4523"></A></DD>
<DT><STRONG>Oxs_BoxAtlas:</STRONG></DT>
<DD>An axes parallel rectangular parallelepiped,
containing a single region that is coterminous with the atlas itself.
The specify block has the form
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_BoxAtlas:</TT><I>atlasname</I> <TT>{</TT>
<DD><TT>xrange {</TT> <I>xmin</I><TT>&nbsp;</TT><I>xmax</I> <TT>}</TT>
<DD><TT>yrange {</TT> <I>ymin</I><TT>&nbsp;</TT><I>ymax</I> <TT>}</TT>
<DD><TT>zrange {</TT> <I>zmin</I><TT>&nbsp;</TT><I>zmax</I> <TT>}</TT>
<DD><TT>name </TT> <I>regionname</I>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
where <I> xmin, xmax, ...</I> are coordinates in meters, specifying
the extents of the volume being defined.  The <I> regionname</I> label
specifies the name assigned to the region contained in the atlas.  The
<B>name</B> entry is optional; if not specified then the
region name is taken from the object instance name, i.e.,
<I> atlasname</I>.

<P>
<B>Examples:</B> <TT><B>sample.mif</B></TT>, <TT><B>cgtest.mif</B></TT>.

<P>
<A NAME="IA"></A><A NAME="4531"></A></DD>
<DT><STRONG>Oxs_ImageAtlas:<A NAME="html:oxsImageAtlas"></A></STRONG></DT>
<DD><A NAME="4533"></A><A NAME="4534"></A>
This class is designed to allow an image file
to be used to define regions in terms of colors in the image.  It is
intended for use in conjunction with the <TT>Oxs_AtlasScalarField</TT> and
<TT>Oxs_AtlasVectorField</TT> classes in circumstances where a small
number of distinct species (materials) are being modeled.  This provides
a generalization of the <A HREF="MIF_1.1.html#sec:partgeometry">mask file</A>
functionality of the 2D solver
(Sec.&nbsp;<A HREF="MIF_1.1.html#sec:partgeometry">17.1.3</A>).

<P>
For situations requiring continuous variation in material parameters,
the script field classes should be used in conjunction with the
<TT>ReadFile</TT> MIF extension command.  See the
<TT>ColorField</TT> sample proc in the <A HREF="MIF_2.1.html#html:ReadFile"><TT>ReadFile</TT>
documentation</A>  for an example of this
technique.

<P>
The <TT>Oxs_ImageAtlas</TT> Specify block has the following form:
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_ImageAtlas:</TT><I>name</I> <TT>{</TT>
<DD><TT>xrange {</TT> <I>xmin</I><TT>&nbsp;</TT><I>xmax</I> <TT>}</TT>
<DD><TT>yrange {</TT> <I>ymin</I><TT>&nbsp;</TT><I>ymax</I> <TT>}</TT>
<DD><TT>zrange {</TT> <I>zmin</I><TT>&nbsp;</TT><I>zmax</I> <TT>}</TT>
<DD><TT>viewplane </TT> <I>view</I>
<DD><TT>image </TT> <I>pic</I>
<DD><TT>colormap {</TT><DL>
   <DD><I>color-1</I><TT>&nbsp;</TT><I>region_name</I>
   <DD><I>color-2</I><TT>&nbsp;</TT><I>region_name</I>
   <DD> ...
   <DD><I>color-n</I><TT>&nbsp;</TT><I>region_name</I>
</DL><TT>}</TT>
<DD><TT>matcherror </TT> <I>max_color_distance</I>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
The <B>xrange</B>, <B>yrange</B>, <B>zrange</B> entries
specify the extent of the atlas, in meters.  The <B>viewplane</B>
<I> view</I> value should be one of the three two-letter codes <TT>xy</TT>,
<TT>zx</TT> or <TT>yz</TT>, which specify the mapping of the horizontal and
vertical axes of the image respectively to axes in the simulation.  The
image is scaled as necessary along each dimension to match the atlas
extents along the corresponding axes.  The image is overlaid through the
entire depth of the perpendicular dimension, i.e., along the axis absent
from the <TT>viewplane</TT> specification.  The
<TT>Oxs_ImageAtlas</TT> class can be used inside a
<TT>Oxs_MultiAtlas</TT> object to specify regions in a multilayer
structure.

<P>
The <B>image</B> entry specifies the name of the image file to use.
If the file path is relative, then it will be taken with respect to the
directory containing the MIF file.  The image format may be any of
those recognized by <A HREF="Bitmap_File_Format_Conversi.html#sec:any2ppm"><TT>any2ppm</TT></A>.  The file will be read directly by Oxs if it is
in the P3 or P6 PPM formats, otherwise <TT>any2ppm</TT> will be
automatically launched to perform the conversion.

<P>
The <B>colormap</B> value is an even length list of color + region
name pairs.  The colors may be specified in any of several ways.  The
most explicit is to use one of the Tk numeric formats,
<TT>#</TT>rgb, <TT>#</TT>rrggbb, <TT>#</TT>rrrgggbbb or <TT>#</TT>rrrrggggbbbb, where
each r, g, and b is one hex digit (i.e., 0-9 or A-F) representing the
red, green and blue components of the color, respectively.  For example,
<TT>#</TT>F00 is bright (full-scale) red, <TT>#</TT>800 would be a darker red, while
<TT>#</TT>FF0 and <TT>#</TT>FFFF00 would both be bright yellow.  Refer to the
<TT>Tk_GetColor</TT> documentation for details.  For shades of gray the
special notation <TT>grayD</TT> or <TT>greyD</TT> is available, where D is a
decimal value between 0 and 100, e.g., <TT>grey0</TT> is black and
<TT>grey100</TT> is white.  Alternatively, one may use any of the symbolic
names defined in the <TT><B>oommf/config/colors.config</B></TT> file, such as
<TT>red</TT>, <TT>white</TT> and <TT>skyblue</TT>.  When comparing symbolic names,
spaces and capitalization are ignored.  The list of symbolic names can
be extended by adding additional files to the <TT>Color filename</TT> option
in the <TT><B>options.tcl</B></TT> <A HREF="Advanced_Installation.html#sec:custom">customization file</A>.  Finally, one <I> color</I> in the
<TT>colormap</TT> list may optionally be the special keyword ``default''.
All pixels that don't match any of the other specified colors (as
determined by the <TT>matcherror</TT> option) are assigned to region
paired with <TT>default</TT>.

<P>
Each of the specified colors should be distinct, but the region names
are allowed to be repeated as desired.  The region names may be chosen
arbitrarily, except the special keyword ``universe'' is reserved for
points not in any of the regions.  This includes all points outside the
atlas bounding box defined by the <TT>xrange</TT>, <TT>yrange</TT>, <TT>zrange</TT>
entries, but may also include points inside that boundary.

<P>
Pixels in the image are assigned to regions by comparing the color of
the pixel to the list of colors specified in <TT>colormap</TT>.  If the
pixel color is closer to a <TT>colormap</TT> color than
<I> max_color_distance</I>, then the colors are considered matched.
If a pixel color matches exactly one <TT>colormap</TT> color, then the pixel
is assigned to the corresponding region.  If a pixel color matches more
than one <TT>colormap</TT> color, the pixel is assigned to the region
corresponding to the closest match.  If a pixel color doesn't match any
of the <TT>colormap</TT> colors, then it is assigned to the <I>default
region</I>, which is the region paired with the ``default'' keyword.  If
<TT>default</TT> does not explicitly appear in the <TT>colormap</TT> colors
list, then <TT>universe</TT> is made the default region.

<P>
To calculate the distance between two colors, each color is first
converted to a scaled triplet of floating point red, green, and blue
values, <B>(<I>r</I>, <I>g</I>, <I>b</I>)</B>
<!-- MATHEND
 
 -->
, where each component lies in the interval <B>[0, 1]</B>
<!-- MATHEND
 
 -->
,
with <B>(0, 0, 0)</B>
<!-- MATHEND
 
 -->
 representing black and <B>(1, 1, 1)</B>
<!-- MATHEND
 
 -->
 representing white.  For
example, <B>(0, 0, 1)</B>
<!-- MATHEND
 
 -->
 is bright blue.  Given two colors in this
representation, the distance is computed using the standard Euclidean
norm with uniform weights, i.e., the distance between <!-- MATH
 $(r_1,g_1,b_1)$
 -->
<B>(<I>r</I><SUB>1</SUB>, <I>g</I><SUB>1</SUB>, <I>b</I><SUB>1</SUB>)</B>
<!-- MATHEND
 
 -->
and <!-- MATH
 $(r_2,g_2,b_2)$
 -->
<B>(<I>r</I><SUB>2</SUB>, <I>g</I><SUB>2</SUB>, <I>b</I><SUB>2</SUB>)</B>
<!-- MATHEND
 
 -->
 and is
<P><!-- MATH
 \begin{displaymath}
\sqrt{(r_1-r_2)^2 + (g_1-g_2)^2 + (b_1-b_2)^2}.
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<BIG><B><IMG
 WIDTH="314" HEIGHT="53" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.gif"
 ALT="$\displaystyle \sqrt{{(r_1-r_2)^2 + (g_1-g_2)^2 + (b_1-b_2)^2}}$">.</B></BIG>
</DIV><P>
<!-- MATHEND
 
 -->
</P>
Since the difference in any one component is at most 1, the distance
between any two colors is at most <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\sqrt{3}\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="26" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\sqrt{3}\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
.

<P>
As explained above, two colors are considered to match if the distance
between them is less than the specified <B>matcherror</B> value.  If
<I> max_color_distance</I> is sufficiently small, then it may easily
happen that a pixel's color does not match any of the specified region
colors, so the pixel would be assigned to the default region.  On the
other hand, if <I> max_color_distance</I> is larger than
<!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\sqrt{3}\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="26" HEIGHT="21" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\sqrt{3}\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
, then all colors will match, and no pixels will be
assigned to the default region.  If <TT>matcherror</TT> is not specified,
then the default value for <I> max_color_distance</I> is 3, which
means all colors match.

<P>
The following example should help clarify these matters.
<BLOCKQUOTE><PRE>
Specify Oxs_ImageAtlas:atlas {
    xrange { 0 400e-9 }
    yrange { 0 200e-9 }
    zrange { 0  20e-9 }
    image  mypic.gif
    viewplane "xy"
    colormap {
        blue   cobalt
        red    permalloy
        green  universe
        default cobalt
    }
    matcherror .1
}
</PRE>
</BLOCKQUOTE>
Blue pixels get mapped to the ``cobalt'' region and red pixels
to the ``permalloy'' region.  Green pixels are mapped to the
``universe'' non-region, which means they are considered to be outside
the atlas entirely.  This is a fine point, but comes into
play when atlases with overlapping bounding boxes are brought together
inside an <TT>Oxs_MultiAtlas</TT>.  To which region would an orange pixel
be assigned?  The scaled triplet representation for orange is
<!-- MATH
 $(1,0.647,0)$
 -->
<B>(1, 0.647, 0)</B>
<!-- MATHEND
 
 -->
, so the distance to blue is <B>1.191</B>
<!-- MATHEND
 
 -->
, the distance to red
is <B>0.647</B>
<!-- MATHEND
 
 -->
, and the distance to green is <B>1.06</B>
<!-- MATHEND
 
 -->
.  Thus the closest color
is red, but <B>0.647</B>
<!-- MATHEND
 
 -->
 is outside the <TT>matcherror</TT> setting of <B>0.1</B>
<!-- MATHEND
 
 -->
, so
orange doesn't match any of the colors and is hence assigned to the
default region, which in this case is cobalt.  On the other hand, if
<TT>matcherror</TT> had been set to say 1, then orange and red would match
and orange would be assigned to the permalloy region.

<P>
Pixels with colors that are equidistant to and match more than one color
in the colormap will be assigned to one of the closest color regions.
The user should not rely on any particular selection, that is to say,
the explicit matching procedure in this case is not defined.
<A NAME="4613"></A><A NAME="4614"></A>

<P>
<B>Examples:</B> <TT><B>imageatlas.mif</B></TT>, <TT><B>grill.mif</B></TT>.

<P>
<A NAME="MA"></A><A NAME="4618"></A></DD>
<DT><STRONG>Oxs_MultiAtlas:</STRONG></DT>
<DD>This atlas is built up as an ordered list of
other atlases.  The set of regions defined by the <TT>Oxs_MultiAtlas</TT>
is the union of the regions of all the atlases contained therein.  The
sub-atlases need not be disjoint, however each point is assigned to the
region in the first sub-atlas in the list that contains it, so the
regions defined by the <TT>Oxs_MultiAtlas</TT> are effectively disjoint.

<P>
The <TT>Oxs_MultiAtlas</TT> specify block has the form
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_MultiAtlas:</TT><I>name</I> <TT>{</TT>
<DD> atlas &nbsp;&nbsp; <I>atlas_1_spec</I>
<DD> atlas &nbsp;&nbsp; <I>atlas_2_spec</I>
<DD> ...
<DD><TT>xrange {</TT> <I>xmin<TT>&nbsp;</TT>xmax</I> <TT>}</TT>
<DD><TT>yrange {</TT> <I>ymin<TT>&nbsp;</TT>ymax</I> <TT>}</TT>
<DD><TT>zrange {</TT> <I>zmin<TT>&nbsp;</TT>zmax</I> <TT>}</TT>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
Each <I> atlas_spec</I> may be either a reference to an atlas defined
earlier and outside the current Specify block, or else an inline,
embedded atlas definition.  The bounding box <B>xrange</B>,
<B>yrange</B> and <B>zrange</B> specifications are each
optional.  If not specified the corresponding range for the atlas
bounding box is taken from the minimal bounding box containing all the
sub-atlases.

<P>
If the atlases are not disjoint, then the regions as defined by an
<TT>Oxs_MultiAtlas</TT> can be somewhat different from those of the
individual component atlases.  For example, suppose <TT>regionA</TT> is a
rectangular region in <TT>atlasA</TT> with corner points (5,5,0) and
(10,10,10), and <TT>regionB</TT> is a rectangular region in <TT>atlasB</TT> with
corner points (0,0,0) and (10,10,10).  When composed in the order
<TT>atlasA</TT>, <TT>atlasB</TT> inside an <TT>Oxs_MultiAtlas</TT>, <TT>regionA</TT>
reported by the <TT>Oxs_MultiAtlas</TT> will be the same as <TT>regionA</TT>
reported by <TT>atlasA</TT>, but <TT>regionB</TT> as reported by the
<TT>Oxs_MultiAtlas</TT> will be the ``L'' shaped volume of those points in
<TT>atlasB</TT>'s <TT>regionB</TT> not inside <TT>regionA</TT>.  If the
<TT>Oxs_MultiAtlas</TT> is constructed with <TT>atlasB</TT> first and
<TT>atlasA</TT> second, then <TT>regionB</TT> as reported by the
<TT>Oxs_MultiAtlas</TT> would agree with that reported by <TT>atlasB</TT>, but
<TT>regionA</TT> would be empty.

<P>
NOTE: The <A HREF="MIF_2.1.html#par:specifyAttributes"><TT>attributes</TT></A> key label
 is not supported by this
class.

<P>
<B>Examples:</B> <TT><B>manyregions-multiatlas.mif</B></TT>, <TT><B>spinvalve.mif</B></TT>,
<TT><B>spinvalve-af.mif</B></TT>, <TT><B>yoyo.mif</B></TT>.

<P>
<A NAME="SA"></A><A NAME="4658"></A></DD>
<DT><STRONG>Oxs_ScriptAtlas:</STRONG></DT>
<DD>An atlas where the regions are defined via a Tcl script.  The specify
block has the form
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_ScriptAtlas:</TT><I>name</I> <TT>{</TT>
<DD><TT>xrange {</TT> <I>xmin<TT>&nbsp;</TT>xmax</I> <TT>}</TT>
<DD><TT>yrange {</TT> <I>ymin<TT>&nbsp;</TT>ymax</I> <TT>}</TT>
<DD><TT>zrange {</TT> <I>zmin<TT>&nbsp;</TT>zmax</I> <TT>}</TT>
<DD><TT>regions {</TT>
 <I>rname_1<TT>&nbsp;</TT>rname_2<TT>&nbsp;</TT>...<TT>&nbsp;</TT>rname_n</I>
 <TT>}</TT>
<DD><TT>script_args {</TT> <I>args_request</I> <TT>}</TT>
<DD><TT>script </TT> <I>Tcl_script</I>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
Here <I> xmin, xmax, ...</I> are coordinates in meters, specifying
the extents of the axes-parallel rectangular parallelepiped enclosing
the total volume being identified.  This volume is subdivided
into <I> n</I> sub-regions, using the names as given in the
<B>regions</B> list.  The <B>script</B> is used to assign
points to the various regions.  Appended to the script are the arguments
requested by <B>script_args</B>, in the manner explained in the
<A HREF="MIF_2.1.html#par:supportProcs">User Defined Support Procedures</A> section of the
MIF&nbsp;2 file format documentation.  The value <I> args_request</I>
should be a subset of <TT> {relpt rawpt minpt maxpt span }</TT>.  If
<TT>script_args</TT> is not specified, the default value <TT>relpt</TT> is
used.  When executed, the return value from the script should be an
integer in the range <B>1</B>
<!-- MATHEND
 
 -->
 to <B><I>n</I></B>
<!-- MATHEND
 
 -->
, indicating the user-defined region in
which the point lies, or else <B>0</B>
<!-- MATHEND
 
 -->
 if the point is not in any
of the <B><I>n</I></B>
<!-- MATHEND
 
 -->
 regions.  Region index <B>0</B>
<!-- MATHEND
 
 -->
 is reserved for the implicit
``universe'' region, which is all-encompassing.  The following example
may help clarify the discussion:
<BLOCKQUOTE>
<PRE>
proc Octs { cellsize x y z xmin ymin zmin xmax ymax zmax } {
    set xindex [expr {int(floor(($x-$xmin)/$cellsize))}]
    set yindex [expr {int(floor(($y-$ymin)/$cellsize))}]
    set zindex [expr {int(floor(($z-$zmin)/$cellsize))}]
    set octant [expr {1+$xindex+2*$yindex+4*$zindex}]
    if {$octant&lt;1 || $octant&gt;8} {
       return 0
    }
    return $octant
}

Specify Oxs_ScriptAtlas:octant {
    xrange {-20e-9 20e-9}
    yrange {-20e-9 20e-9}
    zrange {-20e-9 20e-9}
    regions { VIII V VII VI IV I III II }
    script_args { rawpt minpt maxpt }
    script { Octs 20e-9 }
}
</PRE>
</BLOCKQUOTE>
This atlas divides the rectangular volume between <!-- MATH
 $(-20,-20,-20)$
 -->
<B>(- 20, - 20, - 20)</B>
<!-- MATHEND
 
 -->
 and
<!-- MATH
 $(20,20,20)$
 -->
<B>(20, 20, 20)</B>
<!-- MATHEND
 
 -->
 (nm) into eight regions, corresponding to the standard
octants, I through VIII.  The <TT>Octs</TT> Tcl procedure returns a
value between 1 and 8, with 1 corresponding to octant VIII and 8 to
octant II.  The canonical octant ordering starts with I as the
<B>+ <I>x</I>, + <I>y</I>, + <I>z</I></B>
<!-- MATHEND
 
 -->
 space, proceeds counterclockwise in the <B>+ <I>z</I></B>
<!-- MATHEND
 
 -->
 half-space, and
concludes in the <B>- <I>z</I></B>
<!-- MATHEND
 
 -->
 half-space with V directly beneath I, VI beneath
II, etc.  The ordering computed algorithmically in <TT>Octs</TT>
starts with 1 for the <B>- <I>x</I>, - <I>y</I>, - <I>z</I></B>
<!-- MATHEND
 
 -->
 space, 2 for the <B>+ <I>x</I>, - <I>y</I>, - <I>z</I></B>
<!-- MATHEND
 
 -->
 space, 3
for the <B>- <I>x</I>, + <I>y</I>, - <I>z</I></B>
<!-- MATHEND
 
 -->
 space, etc.  The conversion between the two systems
is accomplished by the ordering of the <TT>regions</TT> list.

<P>
<B>Examples:</B> <TT><B>manyregions-scriptatlas.mif</B></TT>, <TT><B>octant.mif</B></TT>,
<TT><B>tclshapes.mif</B></TT>, <TT><B>diskarray.mif</B></TT>, <TT><B>ellipsoid-atlasproc.mif</B></TT>.

<P>
<A NAME="EA"></A><A NAME="4684"></A></DD>
<DT><STRONG>Oxs_EllipsoidAtlas:</STRONG></DT>
<DD>Defines an ellipsoidal region with axes parallel to the coordinate
axes.  This functionality can be obtained using the
<TT>Oxs_ScriptAtlas</TT> class with an appropriate Tcl script, but this
class is somewhat easier to use and faster.  The Specify
block has the form
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_EllipsoidAtlas:</TT><I>atlasname</I> <TT>{</TT>
<DD><TT>xrange {</TT> <I>xmin</I><TT>&nbsp;</TT><I>xmax</I> <TT>}</TT>
<DD><TT>yrange {</TT> <I>ymin</I><TT>&nbsp;</TT><I>ymax</I> <TT>}</TT>
<DD><TT>zrange {</TT> <I>zmin</I><TT>&nbsp;</TT><I>zmax</I> <TT>}</TT>
<DD><TT>name </TT> <I>regionname</I>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
Here <I> xmin, xmax, ...</I> are coordinates in meters, specifying
the bounding box for the ellipsoid.  The layout of the Specify
block is exactly the same as for the <TT>Oxs_BoxAtlas</TT> class, except
that in this case the named region is not the whole bounding box but
rather that subvolume that is the interior of the ellipsoid inscribed
inside the bounding box.  Points exterior to that ellipsoid are
assigned to the ``universe'' region.

<P>
As in the <TT>Oxs_BoxAtlas</TT> case, the <I> regionname</I> entry is
optional; if missing, the region name is taken from the object instance
name, i.e., <I> atlasname</I>.

<P>

<B>Example:</B> <TT><B>ellipsoid.mif</B></TT>.  See also
<TT><B>ellipsoid-atlasproc.mif</B></TT> and <TT><B>ellipsoid-fieldproc.mif</B></TT> for
equivalent examples using Tcl scripts.
</DD>
</DL>

<P>

<H3><A NAME="SECTION00083200000000000000"></A><A NAME="sec:Meshes"></A>
<BR>
Meshes
</H3>
Meshes define the discretization impressed on the simulation.  There
should be exactly one mesh declared in a MIF&nbsp;2 file.  The usual
(finite) mesh type is <TT>Oxs_RectangularMesh</TT>.  For simulations that
are periodic along one or more axes, use the
<TT>Oxs_PeriodicRectangularMesh</TT> type.

<P>
<DL>
<DD><A NAME="RM"></A><A NAME="html:oxsrectangularmesh"></A><A NAME="4704"></A>
</DD>
<DT><STRONG>Oxs_RectangularMesh:</STRONG></DT>
<DD>This mesh is comprised of a lattice of rectangular prisms.
The specify block has the form
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_RectangularMesh:</TT><I>name</I> <TT>{</TT>
<DD><TT>cellsize {</TT>
  <I>xstep<TT>&nbsp;</TT>ystep<TT>&nbsp;</TT>zstep</I>
  <TT>}</TT>
<DD><TT>atlas </TT> <I>atlas_spec</I>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
This creates an axes parallel rectangular mesh across the entire space
covered by <B>atlas</B>.  The mesh sample rates along each axis are
specified by <B>cellsize</B> (in meters).  The mesh is
cell-based, with the center of the first cell one half step in from the
minimal extremal point (xmin,ymin,ymax) for <I> atlas_spec</I>.
The <I> name</I> is commonly set to ``mesh'', in which case the mesh
object may be referred to by other <TT>Oxs_Ext</TT> objects by the short
name <TT>:mesh</TT>.

<P>
<B>Examples:</B> <TT><B>sample.mif</B></TT>, <TT><B>stdprob3.mif</B></TT>, <TT><B>stdprob4.mif</B></TT>.

<P>
<A NAME="PRM"></A><A NAME="html:oxsperiodicrectangularmesh"></A><A NAME="4716"></A>
</DD>
<DT><STRONG>Oxs_PeriodicRectangularMesh:</STRONG></DT>
<DD>Like the <TT>Oxs_RectangularMesh</TT>, this mesh is also comprised of a
lattice of rectangular prisms.  However, in this case the
mesh is declared to be periodic along one or more of the axis
directions.  The specify block has the form
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_PeriodicRectangularMesh:</TT><I>name</I> <TT>{</TT>
<DD><TT>cellsize {</TT>
  <I>xstep<TT>&nbsp;</TT>ystep<TT>&nbsp;</TT>zstep</I>
  <TT>}</TT>
<DD><TT>atlas </TT> <I>atlas_spec</I>
<DD><TT>periodic </TT> <I>periodic_axes</I>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
The <B>atlas</B> and <B>cellsize</B> values are the same as
for the <TT>Oxs_RectangularMesh</TT> class.  The <I> periodic_axis</I>
value should be a string consisting of one or more of the letters
``x'', ``y'', or ``z'', denoting the periodic direction(s).
<TT>Oxs_Ext</TT> objects that are incompatible with
<TT>Oxs_PeriodicRectangularMesh</TT> will issue an error message at
runtime.  In particular, the
<A HREF="#html:oxsdemag"><TT>Oxs_Demag</TT></A> class supports
periodicity in none or one direction, but not more.  Also, some
third-party extensions provide independent periodicity support using
the older <TT>Oxs_RectangularMesh</TT> class rather than
<TT>Oxs_PeriodicRectangularMesh</TT>.

<P>
<B>Examples:</B> <TT><B>pbcbrick.mif</B></TT>, <TT><B>pbcstripes.mif</B></TT>.

<P>
</DD>
</DL>

<P>

<H3><A NAME="SECTION00083300000000000000">
Energies</A>
</H3>
The following subsections describe the available energy terms.  In
order to be included in the simulation energy and field calculations,
each energy term must be declared in its own, top-level Specify block,
i.e., energy terms should not be declared inline inside other
<TT>Oxs_Ext</TT> objects.  There is no limitation on the number of energy
terms that may be specified in the input MIF file.  Many of these
terms have spatially varying parameters that are initialized via
<A HREF="#sec:oxsFieldObjects"><I> field_object_spec</I>
entries</A> in their
<A HREF="MIF_2.1.html#par:oxsExtReferencing">Specify initialization block</A>.

<P>
<B>Outputs:</B> For each magnetization configuration, three standard
outputs are provided by all energy terms: the scalar output
``Energy,'' which is the total energy in joules contributed by this
energy term, the scalar field output ``Energy density,'' which is a
cell-by-cell map of the energy density in
J/m<SUP>3</SUP>,
and the three-component vector field output ``Field,'' which is the
pointwise field in A/m.  If the code was compiled with the macro
<TT>NDEBUG</TT> not defined, then there will be an additional scalar
output, ``Calc count,'' which counts the number of times the term has
been calculated in the current simulation.  This is intended for
debugging purposes only; this number should agree with the ``Energy
calc count'' value provided by the evolver.

<P>

<UL>
<LI><B>Anisotropy Energy</B>
<DL>
<DD><A NAME="UA"></A><A NAME="4749"></A></DD>
<DT><STRONG>Oxs_UniaxialAnisotropy:</STRONG></DT>
<DD>Uniaxial magneto-crystalline
  anisotropy.  The Specify block has the form
   <BLOCKQUOTE><DL><DT>
   <TT>Specify Oxs_UniaxialAnisotropy:</TT><I>name</I> <TT>{</TT>
       <DD> <TT>K1 </TT><I>K</I>
       <DD> <TT>Ha </TT><I>H</I>
       <DD> <TT>axis </TT><I>u</I>
   <DT><TT>}</TT></DL></BLOCKQUOTE><P>
Exactly one of either <B>K1</B> or <B>Ha</B> should be
  specified, where <B>K1</B> is the crystalline anisotropy constant
  (in
  J/m<sup>3</sup>),
  and <B>Ha</B> is the anistropy field (in A/m).  In either case,
  <B>axis</B> is the anisotropy direction.  <B>K1</B>,
  <B>Ha</B>, and <B>axis</B> may each be varied cellwise across
  the mesh: <B>K1</B> and <B>Ha</B> are initialized with scalar
  field objects, while <B>axis</B> takes a vector field object.  (A
  constant value will be interpreted as a uniform field object having
  the stated value, as usual.)  The axis direction must be non-zero at
  each point, and will be normalized to unit magnitude before being
  used.

<P>
The axis direction is an easy axis if <B>K1</B> (or <B>Ha</B>)
  is <B>&gt;</B>
<!-- MATHEND
 
 -->
0, in which case the cellwise anisotropy energy density (in
  J/m<B><SUP>3</SUP></B>
<!-- MATHEND
 
 -->
) is given by
   <P><!-- MATH
 \begin{displaymath}
E_i = K_i(1 - \textbf{m}_i\cdot\textbf{u}_i)^2 \qquad \mbox{or} \qquad
               \frac{1}{2}\, \mu_0 M_s H_i (1 - \textbf{m}_i\cdot\textbf{u}_i)^2,
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<BIG><B><I>E</I><SUB>i</SUB> = <I>K</I><SUB>i</SUB>(1 - <B>m</B><SUB>i</SUB><SUP> . </SUP><B>u</B><SUB>i</SUB>)<SUP>2</SUP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<IMG
 WIDTH="19" HEIGHT="61" ALIGN="MIDDLE" BORDER="0"
 SRC="img5.gif"
 ALT="$\displaystyle {\frac{{1}}{{2}}}$">&nbsp;<IMG
 WIDTH="25" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img6.gif"
 ALT="$\displaystyle \mu_{0}^{}$"><I>M</I><SUB>s</SUB><I>H</I><SUB>i</SUB>(1 - <B>m</B><SUB>i</SUB><SUP> . </SUP><B>u</B><SUB>i</SUB>)<SUP>2</SUP>,</B></BIG>
</DIV><P>
<!-- MATHEND
 
 -->
</P>
respectively.  (Here <B><I>m</I><SUB>i</SUB></B>
<!-- MATHEND
 
 -->
 is the unit magnetization and <B><I>M</I><SUB>s</SUB></B>
<!-- MATHEND
 
 -->
 the
  saturation magnetization in cell <B><I>i</I></B>
<!-- MATHEND
 
 -->
.)  Otherwise, if <B>K1</B>
  (or <B>Ha</B>) is <B>&lt; 0</B>
<!-- MATHEND
 
 -->
, the axis direction is the normal to the
  easy plane and the cellwise anisotropy energy density is given by
   <P><!-- MATH
 \begin{displaymath}
E_i = -K_i(\textbf{m}_i\cdot\textbf{u}_i)^2 \qquad \mbox{or} \qquad
               -\frac{1}{2}\, \mu_0 M_s H_i (\textbf{m}_i\cdot\textbf{u}_i)^2.
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<BIG><B><I>E</I><SUB>i</SUB> = - <I>K</I><SUB>i</SUB>(<B>m</B><SUB>i</SUB><SUP> . </SUP><B>u</B><SUB>i</SUB>)<SUP>2</SUP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - <IMG
 WIDTH="19" HEIGHT="61" ALIGN="MIDDLE" BORDER="0"
 SRC="img5.gif"
 ALT="$\displaystyle {\frac{{1}}{{2}}}$">&nbsp;<IMG
 WIDTH="25" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img6.gif"
 ALT="$\displaystyle \mu_{0}^{}$"><I>M</I><SUB>s</SUB><I>H</I><SUB>i</SUB>(<B>m</B><SUB>i</SUB><SUP> . </SUP><B>u</B><SUB>i</SUB>)<SUP>2</SUP>.</B></BIG>
</DIV><P>
<!-- MATHEND
 
 -->
</P>
The formulae in the two cases (easy axis vs. easy plane) differ by a
  constant offset, and in each case the energy is non-negative.

<P>
<B>Examples:</B> <TT><B>diskarray.mif</B></TT>, <TT><B>stdprob3.mif</B></TT>, <TT><B>grill.mif</B></TT>.

<P>
<A NAME="CA"></A><A NAME="4782"></A></DD>
<DT><STRONG>Oxs_CubicAnisotropy:</STRONG></DT>
<DD>Cubic magneto-crystalline anisotropy.
  The Specify block has the form
   <BLOCKQUOTE><DL><DT>
   <TT>Specify Oxs_CubicAnisotropy:</TT><I>name</I> <TT>{</TT>
       <DD> <TT>K1 </TT><I>K</I>
       <DD> <TT>Ha </TT><I>H</I>
       <DD> <TT>axis1 </TT><I>u<sub>1</sub></I>
       <DD> <TT>axis2 </TT><I>u<sub>2</sub></I>
   <DT><TT>}</TT></DL></BLOCKQUOTE><P>
Exactly one of either <B>K1</B> or <B>Ha</B> should be
  specified, where <B>K1</B> is the crystalline anisotropy constant
  (in
  J/m<sup>3</sup>),
  and <B>Ha</B> is the anistropy field (in A/m).  In either case,
  <B>axis1</B> and <B>axis2</B> are two anisotropy directions;
  the third anisotropy axis <B><I>u</I><SUB>3</SUB></B>
<!-- MATHEND
 
 -->
 is computed as the vector product,
  <!-- MATH
 $u_1\times u_2$
 -->
<B><I>u</I><SUB>1</SUB> <TT>x</TT> <I>u</I><SUB>2</SUB></B>
<!-- MATHEND
 
 -->
.  For each cell, the axis directions are easy axes if
  <B>K1</B> (or <B>Ha</B>) is <B>&gt;</B>
<!-- MATHEND
 
 -->
0, or hard axes if
  <B>K1</B> (or <B>Ha</B>) is <B>&lt;</B>
<!-- MATHEND
 
 -->
0.  All may be varied cellwise
  across the mesh.  <B>K1</B> or <B>Ha</B> is initialized with a
  scalar field object, and the axis directions are initialized with
  vector field objects.  (Constant values will be interpreted as uniform
  fields with the indicated value, as usual.)  The <B>axis1</B> and
  <B>axis2</B> directions must be mutually orthogonal and non-zero
  at each point (<B><I>u</I><SUB>1</SUB></B>
<!-- MATHEND
 
 -->
 and <B><I>u</I><SUB>2</SUB></B>
<!-- MATHEND
 
 -->
 are automatically scaled to unit
  magnitude before use).

<P>
The anisotropy energy density (in J/m<B><SUP>3</SUP></B>
<!-- MATHEND
 
 -->
) for cell <B><I>i</I></B>
<!-- MATHEND
 
 -->
 is given by
   <P><!-- MATH
 \begin{displaymath}
E_i = K_i\left(a_1^2a_2^2 + a_2^2a_3^2 + a_3^2a_1^2\right),
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<BIG><B><I>E</I><SUB>i</SUB> = <I>K</I><SUB>i</SUB><IMG
 WIDTH="17" HEIGHT="48" ALIGN="MIDDLE" BORDER="0"
 SRC="img7.gif"
 ALT="$\displaystyle \left(\vphantom{a_1^2a_2^2 + a_2^2a_3^2 + a_3^2a_1^2}\right.$"><I>a</I><SUB>1</SUB><SUP>2</SUP><I>a</I><SUB>2</SUB><SUP>2</SUP> + <I>a</I><SUB>2</SUB><SUP>2</SUP><I>a</I><SUB>3</SUB><SUP>2</SUP> + <I>a</I><SUB>3</SUB><SUP>2</SUP><I>a</I><SUB>1</SUB><SUP>2</SUP><IMG
 WIDTH="17" HEIGHT="48" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.gif"
 ALT="$\displaystyle \left.\vphantom{a_1^2a_2^2 + a_2^2a_3^2 + a_3^2a_1^2}\right)$">,</B></BIG>
</DIV><P>
<!-- MATHEND
 
 -->
</P>
or
   <P><!-- MATH
 \begin{displaymath}
E_i = \frac{1}{2}\, \mu_0 M_s H_i 
         \left(a_1^2a_2^2 + a_2^2a_3^2 + a_3^2a_1^2\right),
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<BIG><B><I>E</I><SUB>i</SUB> = <IMG
 WIDTH="19" HEIGHT="61" ALIGN="MIDDLE" BORDER="0"
 SRC="img5.gif"
 ALT="$\displaystyle {\frac{{1}}{{2}}}$">&nbsp;<IMG
 WIDTH="25" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img6.gif"
 ALT="$\displaystyle \mu_{0}^{}$"><I>M</I><SUB>s</SUB><I>H</I><SUB>i</SUB><IMG
 WIDTH="17" HEIGHT="48" ALIGN="MIDDLE" BORDER="0"
 SRC="img7.gif"
 ALT="$\displaystyle \left(\vphantom{a_1^2a_2^2 + a_2^2a_3^2 + a_3^2a_1^2}\right.$"><I>a</I><SUB>1</SUB><SUP>2</SUP><I>a</I><SUB>2</SUB><SUP>2</SUP> + <I>a</I><SUB>2</SUB><SUP>2</SUP><I>a</I><SUB>3</SUB><SUP>2</SUP> + <I>a</I><SUB>3</SUB><SUP>2</SUP><I>a</I><SUB>1</SUB><SUP>2</SUP><IMG
 WIDTH="17" HEIGHT="48" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.gif"
 ALT="$\displaystyle \left.\vphantom{a_1^2a_2^2 + a_2^2a_3^2 + a_3^2a_1^2}\right)$">,</B></BIG>
</DIV><P>
<!-- MATHEND
 
 -->
</P>
where <!-- MATH
 $a_1 = \textbf{m}\cdot\textbf{u}_1$
 -->
<B><I>a</I><SUB>1</SUB> = <B>m</B><SUP> . </SUP><B>u</B><SUB>1</SUB></B>
<!-- MATHEND
 
 -->
, <!-- MATH
 $a_2 = \textbf{m}\cdot\textbf{u}_2$
 -->
<B><I>a</I><SUB>2</SUB> = <B>m</B><SUP> . </SUP><B>u</B><SUB>2</SUB></B>
<!-- MATHEND
 
 -->
, <!-- MATH
 $a_3 =
  \textbf{m}\cdot\textbf{u}_3$
 -->
<B><I>a</I><SUB>3</SUB> = <B>m</B><SUP> . </SUP><B>u</B><SUB>3</SUB></B>
<!-- MATHEND
 
 -->
, for reduced (normalized) magnetization <B><I>m</I></B>
<!-- MATHEND
 
 -->
 and
  orthonormal anisotropy axes <!-- MATH
 $\textbf{u}_1$
 -->
<B><B>u</B><SUB>1</SUB></B>
<!-- MATHEND
 
 -->
, <!-- MATH
 $\textbf{u}_2$
 -->
<B><B>u</B><SUB>2</SUB></B>
<!-- MATHEND
 
 -->
, and <!-- MATH
 $\textbf{u}_3$
 -->
<B><B>u</B><SUB>3</SUB></B>
<!-- MATHEND
 
 -->
 at cell <B><I>i</I></B>
<!-- MATHEND
 
 -->
.
  In the second form, <B><I>M</I><SUB>s</SUB></B>
<!-- MATHEND
 
 -->
 is the saturation magnetization in cell <B><I>i</I></B>
<!-- MATHEND
 
 -->
.
  For each cell, if <B>K1</B> (resp. <B>Ha</B>) is <B>&gt;</B>
<!-- MATHEND
 
 -->
0 then
  the computed energy will be non-negative, otherwise for <B>K1</B>
  (resp. <B>Ha</B>) <B>&lt;</B>
<!-- MATHEND
 
 -->
0 the computed energy will be non-positive.

<P>
<B>Examples:</B> <TT><B>cgtest.mif</B></TT>, <TT><B>sample2.mif</B></TT>, <TT><B>grill.mif</B></TT>.

<P>
</DD>
</DL>

<P>
</LI>
<LI><B>Exchange Energy</B>
<DL>
<DD><A NAME="E6"></A><A NAME="4817"></A></DD>
<DT><STRONG>Oxs_Exchange6Ngbr:</STRONG></DT>
<DD>Standard 6-neighbor exchange energy.  The
   exchange energy density contribution from cell <B><I>i</I></B>
<!-- MATHEND
 
 -->
 is given by
   
<P></P>
<DIV ALIGN="CENTER">
<A NAME="eq:ExchangeEnergy"></A><!-- MATH
 \begin{equation}
E_i =  \sum_{j\in N_i} A_{ij}
         \frac{\textbf{m}_i\cdot\left(\textbf{m}_i - \textbf{m}_j\right)}{\Delta_{ij}^2}
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><BIG>
<B><I>E</I><SUB>i</SUB> = <IMG
 WIDTH="38" HEIGHT="57" ALIGN="MIDDLE" BORDER="0"
 SRC="img9.gif"
 ALT="$\displaystyle \sum_{{j\in N_i}}^{}$"><I>A</I><SUB>ij</SUB><IMG
 WIDTH="138" HEIGHT="65" ALIGN="MIDDLE" BORDER="0"
 SRC="img10.gif"
 ALT="$\displaystyle {\frac{{\textbf{m}_i\cdot\left(\textbf{m}_i - \textbf{m}_j\right)}}{{\Delta_{ij}^2}}}$"></B>
</BIG></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(1)</TD></TR>
</TABLE>
<!-- MATHEND
 
 -->
</DIV>
where <B><I>N</I><SUB>i</SUB></B>
<!-- MATHEND
 
 -->
 is the set consisting of the 6 cells nearest to cell <B><I>i</I></B>
<!-- MATHEND
 
 -->
,
   <B><I>A</I><SUB>ij</SUB></B>
<!-- MATHEND
 
 -->
 is the exchange coefficient between cells <B><I>i</I></B>
<!-- MATHEND
 
 -->
 and <B><I>j</I></B>
<!-- MATHEND
 
 -->
 in J/m,
   and <!-- MATH
 $\Delta_{ij}$
 -->
<B><IMG
 WIDTH="28" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img11.gif"
 ALT="$ \Delta_{{ij}}^{}$"></B>
<!-- MATHEND
 
 -->
 is the discretization step size between cell <B><I>i</I></B>
<!-- MATHEND
 
 -->
 and
   cell <B><I>j</I></B>
<!-- MATHEND
 
 -->
 (in meters).

<P>
The Specify block for this term has the form
   <BLOCKQUOTE><DL><DT>
   <TT>Specify Oxs_Exchange6Ngbr:</TT><I>name</I> <TT>{</TT>
   <DD><TT>default_A </TT><I>value</I>
   <DD><TT>atlas </TT><I>atlas_spec</I>
   <DD><TT>A {</TT><DL>
       <DD>
        <I>region-1</I><TT>&nbsp;</TT>
          <I>region-1</I><TT>&nbsp;</TT><I>A<SUB>11</SUB></I>
       <DD>
        <I>region-1</I><TT>&nbsp;</TT>
          <I>region-2</I><TT>&nbsp;</TT><I>A<SUB>12</SUB></I>
       <DD> ...
       <DD>
        <I>region-m</I><TT>&nbsp;</TT>
          <I>region-n</I><TT>&nbsp;</TT><I>A<SUB>mn</SUB></I>
   </DL><TT>}</TT>
   <DT><TT>}</TT></DL></BLOCKQUOTE><P>
or
   <BLOCKQUOTE><DL><DT>
   <TT>Specify Oxs_Exchange6Ngbr:</TT><I>name</I> <TT>{</TT>
   <DD><TT>default_lex </TT><I>value</I>
   <DD><TT>atlas </TT><I>atlas_spec</I>
   <DD><TT>lex {</TT><DL>
       <DD>
        <I>region-1</I><TT>&nbsp;</TT>
          <I>region-1</I><TT>&nbsp;</TT><I>lex<SUB>11</SUB></I>
       <DD>
        <I>region-1</I><TT>&nbsp;</TT>
          <I>region-2</I><TT>&nbsp;</TT><I>lex<SUB>12</SUB></I>
       <DD> ...
       <DD>
        <I>region-m</I><TT>&nbsp;</TT>
          <I>region-n</I><TT>&nbsp;</TT><I>lex<SUB>mn</SUB></I>
   </DL><TT>}</TT>
   <DT><TT>}</TT></DL></BLOCKQUOTE><P>
where <B>lex</B> specifies the magnetostatic-exchange length, in
   meters, defined by <!-- MATH
 ${\rm lex} = \sqrt{2A/(\mu_0 M_s^2)}$
 -->
<B><I>lex</I> = <IMG
 WIDTH="100" HEIGHT="43" ALIGN="MIDDLE" BORDER="0"
 SRC="img12.gif"
 ALT="$ \sqrt{{2A/(\mu_0 M_s^2)}}$"></B>
<!-- MATHEND
 
 -->
.

<P>
In the first case, the <B>A</B> block specifies <B><I>A</I><SUB>ij</SUB></B>
<!-- MATHEND
 
 -->
 values
   on a region by region basis, where the regions are labels declared by
   <I> atlas_spec</I>.  This allows for specification of <B><I>A</I></B>
<!-- MATHEND
 
 -->
 both
   inside a given region (e.g., <B><I>A</I><SUB>ii</SUB></B>
<!-- MATHEND
 
 -->
) and along interfaces between
   regions (e.g., <B><I>A</I><SUB>ij</SUB></B>
<!-- MATHEND
 
 -->
).  By symmetry, if <B><I>A</I><SUB>ij</SUB></B>
<!-- MATHEND
 
 -->
 is specified,
   then the same value is automatically assigned to <B><I>A</I><SUB>ji</SUB></B>
<!-- MATHEND
 
 -->
 as well.
   The <B>default_A</B> value is applied to any otherwise
   unassigned <B><I>A</I><SUB>ij</SUB></B>
<!-- MATHEND
 
 -->
.

<P>
In the second case, one specifies the magnetostatic-exchange length
   instead of <B><I>A</I></B>
<!-- MATHEND
 
 -->
, but the interpretation is otherwise analogous.

<P>
Although one may specify <B><I>A</I><SUB>ij</SUB></B>
<!-- MATHEND
 
 -->
 (resp. <!-- MATH
 ${\rm lex}_{ij}$
 -->
<B><I>lex</I><SUB>ij</SUB></B>
<!-- MATHEND
 
 -->
) for any
   pair of regions <B><I>i</I></B>
<!-- MATHEND
 
 -->
 and <B><I>j</I></B>
<!-- MATHEND
 
 -->
, it is only required and only active if
   the region pair are in contact.  If long-range exchange interaction
   is required, use <TT>Oxs_TwoSurfaceExchange</TT>.

<P>
In addition to the standard energy and field outputs,
   <TT>Oxs_Exchange6Ngbr</TT> provides three scalar outputs involving the
   angle between spins at neighboring cells:

<UL>
<LI><B>Max Spin Ang:</B> maximum angle, in degrees, between
  neigboring spins for the current magnetization state.
</LI>
<LI><B>Stage Max Spin Ang:</B> Maximum value of <TT>Max Spin Ang</TT>
  for the current stage.
</LI>
<LI><B>Run Max Spin Ang:</B> Maximum value obtained by
  <TT>Max Spin Ang</TT> during the simulation.
</LI>
</UL>

<P>
<B>Examples:</B> <TT><B>grill.mif</B></TT>, <TT><B>spinvalve.mif</B></TT>, <TT><B>tclshapes.mif</B></TT>.

<P>
<A NAME="UE"></A><A NAME="4855"></A></DD>
<DT><STRONG>Oxs_UniformExchange:</STRONG></DT>
<DD>Similar to <TT>Oxs_Exchange6Ngbr</TT>, except the exchange constant <B><I>A</I></B>
<!-- MATHEND
 
 -->
   (or exchange length <B><I>lex</I></B>
<!-- MATHEND
 
 -->
) is uniform across all space.  The
   Specify block is very simple, consisting of either the label
   <B>A</B> with the desired exchange coefficient value in J/m, or
   the label <B>lex</B> with the desired magnetostatic-exchange
   length in meters.  Since <TT>A</TT> (resp. <TT>lex</TT>) is not spatially
   varying, it is initialized with a simple constant (as opposed to a
   scalar field object).

<P>
In addition to the standard energy and field outputs,
   <TT>Oxs_UniformExchange</TT> provides the three scalar outputs
   <TT>Max Spin Ang</TT>, <TT>Stage Max Spin Ang</TT>, and
   <TT>Run Max Spin Ang</TT> as described for <TT>Oxs_Exchange6Ngbr</TT>.

<P>
<B>Examples:</B> <TT><B>sample.mif</B></TT>, <TT><B>cgtest.mif</B></TT>, <TT><B>stdprob3.mif</B></TT>.

<P>
<A NAME="EP"></A><A NAME="4871"></A></DD>
<DT><STRONG>Oxs_ExchangePtwise:</STRONG></DT>
<DD>The exchange coefficient <B><I>A</I><SUB>i</SUB></B>
<!-- MATHEND
 
 -->
 is specified on
   a point-by-point (or cell-by-cell) basis, as opposed to the pairwise
   specification model used by <TT>Oxs_Exchange6Ngbr</TT>.  The exchange
   energy density at a cell <B><I>i</I></B>
<!-- MATHEND
 
 -->
 is computed across its nearest 6 neighbors,
   <B><I>N</I><SUB>i</SUB></B>
<!-- MATHEND
 
 -->
, using the formula
   <P><!-- MATH
 \begin{displaymath}
E_i =  \sum_{j\in N_i} A_{ij,{\rm eff}}
         \frac{\textbf{m}_i\cdot\left(\textbf{m}_i - \textbf{m}_j\right)}{\Delta_{ij}^2}
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<BIG><B><I>E</I><SUB>i</SUB> = <IMG
 WIDTH="38" HEIGHT="57" ALIGN="MIDDLE" BORDER="0"
 SRC="img9.gif"
 ALT="$\displaystyle \sum_{{j\in N_i}}^{}$"><I>A</I><SUB>ij, eff</SUB><IMG
 WIDTH="138" HEIGHT="65" ALIGN="MIDDLE" BORDER="0"
 SRC="img10.gif"
 ALT="$\displaystyle {\frac{{\textbf{m}_i\cdot\left(\textbf{m}_i - \textbf{m}_j\right)}}{{\Delta_{ij}^2}}}$"></B></BIG>
</DIV><P>
<!-- MATHEND
 
 -->
</P>
where <!-- MATH
 $\Delta_{ij}$
 -->
<B><IMG
 WIDTH="28" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img11.gif"
 ALT="$ \Delta_{{ij}}^{}$"></B>
<!-- MATHEND
 
 -->
 is the discretization step size from cell <B><I>i</I></B>
<!-- MATHEND
 
 -->
 to
   cell <B><I>j</I></B>
<!-- MATHEND
 
 -->
 in meters, and
   <P><!-- MATH
 \begin{displaymath}
A_{ij,{\rm eff}} = \frac{2A_iA_j}{A_i+A_j},
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<BIG><B><I>A</I><SUB>ij, eff</SUB> = <IMG
 WIDTH="76" HEIGHT="63" ALIGN="MIDDLE" BORDER="0"
 SRC="img13.gif"
 ALT="$\displaystyle {\frac{{2A_iA_j}}{{A_i+A_j}}}$">,</B></BIG>
</DIV><P>
<!-- MATHEND
 
 -->
</P>
with <!-- MATH
 $A_{ij,{\rm eff}} = 0$
 -->
<B><I>A</I><SUB>ij, eff</SUB> = 0</B>
<!-- MATHEND
 
 -->
 if <B><I>A</I><SUB>i</SUB></B>
<!-- MATHEND
 
 -->
 and <B><I>A</I><SUB>j</SUB></B>
<!-- MATHEND
 
 -->
 are 0.

<P>
Note that <!-- MATH
 $A_{ij,{\rm eff}}$
 -->
<B><I>A</I><SUB>ij, eff</SUB></B>
<!-- MATHEND
 
 -->
 satisfies
   the following properties:
   <BR>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{eqnarray*}
A_{ij,{\rm eff}} & = & A_{ji,{\rm eff}} \\
        A_{ij,{\rm eff}} & = & A_i \qquad \mbox{if $A_i=A_j$} \\
        \lim_{A_i\downarrow 0} A_{ij,{\rm eff}} & = & 0.
\end{eqnarray*}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><BIG><I>A</I><SUB>ij, eff</SUB></BIG></TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP><BIG>=</BIG></TD>
<TD ALIGN="LEFT" NOWRAP><BIG><I>A</I><SUB>ji, eff</SUB></BIG></TD>
<TD WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><BIG><I>A</I><SUB>ij, eff</SUB></BIG></TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP><BIG>=</BIG></TD>
<TD ALIGN="LEFT" NOWRAP><BIG><I>A</I><SUB>i</SUB>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<IMG
 WIDTH="92" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img14.gif"
 ALT="$\displaystyle \mbox{if $A_i=A_j$}$"></BIG></TD>
<TD WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><BIG><IMG
 WIDTH="35" HEIGHT="46" ALIGN="MIDDLE" BORDER="0"
 SRC="img15.gif"
 ALT="$\displaystyle \lim_{{A_i\downarrow 0}}^{}$"><I>A</I><SUB>ij, eff</SUB></BIG></TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP><BIG>=</BIG></TD>
<TD ALIGN="LEFT" NOWRAP><BIG>0.</BIG></TD>
<TD WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL">

   Additionally, if <B><I>A</I><SUB>i</SUB></B>
<!-- MATHEND
 
 -->
 and <B><I>A</I><SUB>j</SUB></B>
<!-- MATHEND
 
 -->
 are non-negative,
   <P><!-- MATH
 \begin{displaymath}
\min(A_i,A_j) \leq  A_{ij,{\rm eff}}  \leq \max(A_i,A_j).
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<BIG><B>min(<I>A</I><SUB>i</SUB>, <I>A</I><SUB>j</SUB>) <IMG
 WIDTH="20" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img16.gif"
 ALT="$\displaystyle \leq$"> <I>A</I><SUB>ij, eff</SUB> <IMG
 WIDTH="20" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img16.gif"
 ALT="$\displaystyle \leq$"> max(<I>A</I><SUB>i</SUB>, <I>A</I><SUB>j</SUB>).</B></BIG>
</DIV><P>
<!-- MATHEND
 
 -->
</P>
Evaluating the exchange energy with this formulation of <!-- MATH
 $A_{ij,{\rm
   eff}}$
 -->
<B><I>A</I><SUB>ij, eff</SUB></B>
<!-- MATHEND
 
 -->
 is equivalent to finding the minimum possible exchange energy
   between cells <B><I>i</I></B>
<!-- MATHEND
 
 -->
 and <B><I>j</I></B>
<!-- MATHEND
 
 -->
 under the assumption that <B><I>A</I><SUB>i</SUB></B>
<!-- MATHEND
 
 -->
 and <B><I>A</I><SUB>j</SUB></B>
<!-- MATHEND
 
 -->
   are constant in each of the two cells.  Similar considerations are
   made in computing the exchange energy for a <A HREF="MIF_1.1.html#html:mifvariablethickness">2D variable
   thickness model</A> [<A
 HREF="bibliography.html#porter01">16</A>].

<P>
The Specify block for <TT>Oxs_ExchangePtwise</TT> has the form
   <BLOCKQUOTE><DL><DT>
   <TT>Specify Oxs_ExchangePtwise:</TT><I>name</I> <TT>{</TT>
       <DD> <TT>A </TT><I>scalarfield_spec</I>
   <DT><TT>}</TT></DL></BLOCKQUOTE><P>
where <I> scalarfield_spec</I> is an arbitrary
   <A HREF="#sec:oxsFieldObjects">scalar field object</A> returning the desired exchange
   coefficient in J/m.

<P>
In addition to the standard energy and field outputs,
   <TT>Oxs_ExchangePtwise</TT> provides the three scalar outputs
   <TT>Max Spin Ang</TT>, <TT>Stage Max Spin Ang</TT>, and
   <TT>Run Max Spin Ang</TT> as described for <TT>Oxs_Exchange6Ngbr</TT>.

<P>
<B>Example:</B> <TT><B>antidots-filled.mif</B></TT>.

<P>
<A NAME="TS"></A><A NAME="4915"></A></DD>
<DT><STRONG>Oxs_TwoSurfaceExchange:</STRONG></DT>
<DD>Provides long-range bilinear and biquadratic exchange.  Typically
   used to simulate RKKY-style coupling across non-magnetic spacers in
   spinvalves.  The specify block has the form
   <BLOCKQUOTE><DL><DT>
   <TT>Specify Oxs_TwoSurfaceExchange:</TT><I>name</I> <TT>{</TT>
   <DD><TT>sigma  </TT><I>value</I>
   <DD><TT>sigma2 </TT><I>value</I>
   <DD><TT>surface1 {</TT><DL>
       <DD> <TT>atlas </TT><I>atlas_spec</I>
       <DD> <TT>region </TT><I>region_label</I>
       <DD> <TT>scalarfield </TT><I>scalarfield_spec</I>
       <DD> <TT>scalarvalue </TT><I>fieldvalue</I>
       <DD> <TT>scalarside </TT><I>sign</I>
   </DL><TT>}</TT>
   <DD><TT>surface2 {</TT><DL>
       <DD> <TT>atlas </TT><I>atlas_spec</I>
       <DD> <TT>region </TT><I>region_label</I>
       <DD> <TT>scalarfield </TT><I>scalarfield_spec</I>
       <DD> <TT>scalarvalue </TT><I>fieldvalue</I>
       <DD> <TT>scalarside </TT><I>sign</I>
   </DL><TT>}</TT>
   <DT><TT>}</TT></DL></BLOCKQUOTE><P>
Here <B>sigma</B> and <B>sigma2</B> are the bilinear and
   biquadratic surface (interfacial) exchange energies, in
   J/m^2.  Either is optional, with default value
   0.

<P>
The <B>surface1</B> and <B>surface2</B> sub-blocks describe
   the two interacting surfaces.  Each description consists of 5
   name-values pairs, which must be listed in the order shown.  In each
   sub-block, <I> atlas_spec</I> specifies an atlas, and
   <I> region_label</I> specifies a region in that atlas.  These bound
   the extent of the desired surface.  The following
   <B>scalarfield</B>, <B>scalarvalue</B> and
   <B>scalarside</B> entries define a discretized surface inside the
   bounding region.  Here <I> scalarfield_spec</I> references a scalar
   field object, <I> fieldvalue</I> should be a floating point value,
   and <I> sign</I> should be a single character, either `<B>-</B>
<!-- MATHEND
 
 -->
' or
   `<B>+</B>
<!-- MATHEND
 
 -->
'.  If <I> sign</I> is `<B>-</B>
<!-- MATHEND
 
 -->
', then any point for which the
   scalar field object takes a value less than or equal to the
   <TT>scalarvalue</TT> value is considered to be ``inside'' the surface.
   Conversely, if <I> sign</I> is `<B>+</B>
<!-- MATHEND
 
 -->
', then any point for which the
   scalar field object has value greater than or equal to the
   <TT>scalarvalue</TT> value is considered to be ``inside'' the surface.
   The discretized surface determined is the set of all points on the
   problem mesh that are in the bounding region, are either on the
   surface or lie on the ``inside'' side of the surface, and have a
   (nearest-) neighbor that is on the ``outside'' side of the surface.
   A ``neighbor'' is determined by the mesh; in a typical rectangular
   mesh each cell has six neighbors.

<P>
In this way, 2 discrete lists of cells representing the two
   surfaces are obtained.  Each cell from the first list (representing
   <TT>surface1</TT>) is then matched with the closest cell from the
   second list (i.e., from <TT>surface2</TT>).  Note the asymmetry in
   this matching process: each cell from the first list is included in
   exactly one match, but there may be cells in the second list that
   are included in many match pairs, or in none.  If the two surfaces
   are of different sizes, then in practice typically the smaller will
   be made the first surface, because this will usually lead to fewer
   multiply-matched cells, but this designation is not required.

<P>
The resulting exchange energy density at cell <B><I>i</I></B>
<!-- MATHEND
 
 -->
 on one surface
   from matching cell <B><I>j</I></B>
<!-- MATHEND
 
 -->
 on the other is given by
   <P><!-- MATH
 \begin{displaymath}
E_{ij} =  \frac{\sigma\left[1-\textbf{m}_i\cdot\textbf{m}_j\right]
         +\sigma_2\left[1-\left(\textbf{m}_i\cdot\textbf{m}_j\right)^2\right]
        }{\Delta_{ij}}
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<BIG><B><I>E</I><SUB>ij</SUB> = <IMG
 WIDTH="320" HEIGHT="83" ALIGN="MIDDLE" BORDER="0"
 SRC="img17.gif"
 ALT="$\displaystyle {\frac{{\sigma\left[1-\textbf{m}_i\cdot\textbf{m}_j\right]
+\sig...
...\left[1-\left(\textbf{m}_i\cdot\textbf{m}_j\right)^2\right]
}}{{\Delta_{ij}}}}$"></B></BIG>
</DIV><P>
<!-- MATHEND
 
 -->
</P>
where <B><IMG
 WIDTH="14" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img18.gif"
 ALT="$ \sigma$"></B>
<!-- MATHEND
 
 -->
 and <B><IMG
 WIDTH="20" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img19.gif"
 ALT="$ \sigma_{2}^{}$"></B>
<!-- MATHEND
 
 -->
, respectively, are the bilinear and
   biquadratic surface exchange coefficients between the two surfaces,
   in J/m<B><SUP>2</SUP></B>
<!-- MATHEND
 
 -->
, <!-- MATH
 $\textbf{m}_i$
 -->
<B><B>m</B><SUB>i</SUB></B>
<!-- MATHEND
 
 -->
 and <!-- MATH
 $\textbf{m}_j$
 -->
<B><B>m</B><SUB>j</SUB></B>
<!-- MATHEND
 
 -->
 are the normalized, unit spins
   (i.e., magnetization directions) at cells <B><I>i</I></B>
<!-- MATHEND
 
 -->
 and <B><I>j</I></B>
<!-- MATHEND
 
 -->
, and
   <!-- MATH
 $\Delta_{ij}$
 -->
<B><IMG
 WIDTH="28" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img11.gif"
 ALT="$ \Delta_{{ij}}^{}$"></B>
<!-- MATHEND
 
 -->
 is the discretization cell size in the direction from
   cell <B><I>i</I></B>
<!-- MATHEND
 
 -->
 towards cell <B><I>j</I></B>
<!-- MATHEND
 
 -->
, in meters.  Note that if <B><IMG
 WIDTH="14" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img18.gif"
 ALT="$ \sigma$"></B>
<!-- MATHEND
 
 -->
 is
   negative, then the surfaces will be anti-ferromagnetically coupled.
   Likewise, if <B><IMG
 WIDTH="20" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img19.gif"
 ALT="$ \sigma_{2}^{}$"></B>
<!-- MATHEND
 
 -->
 is negative, then the biquadratic term will
   favor orthogonal alignment.

<P>
The following example produces an antiferromagnetic exchange coupling
   between the lower surface of the ``top'' layer and the upper surface
   of the ``bottom'' layer, across a middle ``spacer'' layer.  The
   simple <TT>Oxs_LinearScalarField</TT> object is used here to provide
   level surfaces that are planes orthogonal to the <B><I>z</I></B>
<!-- MATHEND
 
 -->
-axis.  In
   practice this example might represent a spinvalve, where the top and
   bottom layers would be composed of ferromagnetic material and the
   middle layer could be a copper spacer.
<BLOCKQUOTE>
<PRE>
Specify Oxs_MultiAtlas:atlas {
    atlas { Oxs_BoxAtlas {
        name top
        xrange {0 500e-9}
        yrange {0 250e-9}
        zrange {6e-9 9e-9}
    } }
    atlas { Oxs_BoxAtlas {
        name spacer
        xrange {0 500e-9}
        yrange {0 250e-9}
        zrange {3e-9 6e-9}
    } }
    atlas { Oxs_BoxAtlas {
        name bottom
        xrange {0 500e-9}
        yrange {0 250e-9}
        zrange {0 3e-9}
    } }
}

Specify Oxs_LinearScalarField:zheight {
    vector {0 0 1}
    norm   1.0
}

Specify Oxs_TwoSurfaceExchange:AF {
    sigma -1e-4
    surface1 {
               atlas  :atlas
              region  bottom
         scalarfield  :zheight
         scalarvalue  3e-9
          scalarside  -
    }
    surface2 {
               atlas  :atlas
              region  top
         scalarfield  :zheight
         scalarvalue  6e-9
          scalarside  +
    }
}
</PRE>
</BLOCKQUOTE>

<P>
In addition to the standard energy and field outputs,
   <TT>Oxs_TwoSurfaceExchange</TT> provides the three scalar outputs
   <TT>Max Spin Ang</TT>, <TT>Stage Max Spin Ang</TT>, and
   <TT>Run Max Spin Ang</TT> as described for <TT>Oxs_Exchange6Ngbr</TT>.

<P>
<B>Example:</B> <TT><B>spinvalve-af.mif</B></TT>.

<P>
<A NAME="SE"></A><A NAME="4953"></A></DD>
<DT><STRONG>Oxs_RandomSiteExchange:</STRONG></DT>
<DD>A randomized exchange energy.  The Specify block has the form
   <BLOCKQUOTE><DL><DT>
   <TT>Specify Oxs_RandomSiteExchange:</TT><I>name</I> <TT>{</TT>
       <DD> <TT>linkprob </TT><I>probability</I>
       <DD> <TT>Amin </TT><I>A_lower_bound</I>
       <DD> <TT>Amax </TT><I>A_upper_bound</I>
   <DT><TT>}</TT></DL></BLOCKQUOTE><P>
Each adjacent pair of cells <B><I>i</I></B>
<!-- MATHEND
 
 -->
, <B><I>j</I></B>
<!-- MATHEND
 
 -->
, is given <B>linkprob</B>
   probability of having a non-zero exchange coefficient <B><I>A</I><SUB>ij</SUB></B>
<!-- MATHEND
 
 -->
.  Here
   two cells are adjacent if they lie in each other's 6-neighborhood.
   If a pair is found to have a non-zero exchange coefficient, then
   <B><I>A</I><SUB>ij</SUB></B>
<!-- MATHEND
 
 -->
 is drawn uniformly from the range <!-- MATH
 $[\texttt{Amin},\texttt{Amax}]$
 -->
<B>[<texttt>Amin</texttt>,<texttt>Amax</texttt>]</B>
<!-- MATHEND
 
 -->
.
   The exchange energy is computed using (<A HREF="#eq:ExchangeEnergy">1</A>), the
   formula used by the <TT>Oxs_Exchange6Ngbr</TT> energy object.  The
   value <B><I>A</I><SUB>ij</SUB></B>
<!-- MATHEND
 
 -->
 for each pair of cells is determined during problem
   initialization, and is held fixed thereafter.  The limits
   <I> A_lower_bound</I> and <I> A_upper_bound</I> may be any real
   numbers; negative values may be used to weaken the exchange
   interaction arising from other exchange energy terms.  The only
   restriction is that <I> A_lower_bound</I> must not be greater than
   <I> A_upper_bound</I>.  The <TT>linkprob</TT> value <I> probability</I>
   must lie in the range <B>[0, 1]</B>
<!-- MATHEND
 
 -->
.

<P>
In addition to the standard energy and field outputs,
   <TT>Oxs_RandomSiteExchange</TT> provides the three scalar outputs
   <TT>Max Spin Ang</TT>, <TT>Stage Max Spin Ang</TT>, and
   <TT>Run Max Spin Ang</TT> as described for <TT>Oxs_Exchange6Ngbr</TT>.

<P>
<B>Example:</B> <TT><B>randexch.mif</B></TT>.

<P>
</DD>
</DL>

<P>
</LI>
<LI><B>Self-Magnetostatic Energy</B>
<DL>
<DD><A NAME="DE"></A><A NAME="html:oxsdemag"></A><A NAME="4979"></A></DD>
<DT><STRONG>Oxs_Demag:</STRONG></DT>
<DD>Standard demagnetization energy term, built upon
   the assumption that the magnetization is constant in each cell.
   It computes the average demagnetization field in each cell using
   formulae from [<A
 HREF="bibliography.html#aharoni98">2</A>,<A
 HREF="bibliography.html#newell93">15</A>] and convolution
   via the Fast Fourier Transform.  This class supports non-periodic
   simulations if the mesh object in the MIF file is of the
   <A HREF="#html:oxsrectangularmesh"><TT>Oxs_RectangularMesh</TT></A>
   type; simulations periodic along one axis direction are also
   supported when using the
   <A HREF="#html:oxsperiodicrectangularmesh"><TT>Oxs_PeriodicRectangularMesh</TT></A>
   class.  Periodicity in more than one direction is not supported at
   this time.  The specify block has the form
   <BLOCKQUOTE><DL><DT>
   <TT>Specify Oxs_Demag:</TT><I>name</I> <TT>{</TT>
       <DD> <TT>asymptotic_radius </TT><I>radius</I>
   <DT><TT>}</TT></DL></BLOCKQUOTE><P>
The analytic formulae used to compute the demag kernel are
   computationally expensive and inaccurate at large offsets.  At
   offsets larger than <I> radius</I> (measured in cells) asymptotic
   approximations are used instead.  If <B>asymptotic_radius</B> is
   not specified, then the default value 32 is used.  For non-periodic
   simulations, setting <I> radius</I> to -1 causes the analytic
   formulae to be used at all offsets.  The example file
   <TT><B>demagtensor.mif</B></TT> can be used to extract the computed
   demagnetization tensor coefficients for a specified cell geometry;
   see the description at the top of that file for usage details.

<P>
<B>Examples:</B> <TT><B>sample.mif</B></TT>, <TT><B>cgtest.mif</B></TT>, <TT><B>pbcbrick.mif</B></TT>, <TT><B>demagtensor.mif</B></TT>.

<P>
<A NAME="SD"></A><A NAME="4994"></A></DD>
<DT><STRONG>Oxs_SimpleDemag:</STRONG></DT>
<DD>This is the same as the <TT>Oxs_Demag</TT> object, except that
   periodicity is not supported and asymptotic formulae are not used.
   The implementation does not use any of the symmetries
   inherent in the demagnetization kernel, or special properties of the
   Fourier Transform when applied to a real (non-complex) function.
   As a result, the source code is
   considerably simpler than for <TT>Oxs_Demag</TT>, but the run time
   performance and memory usage are poorer.  <TT>Oxs_SimpleDemag</TT> is
   included for validation checks, and as a base for user-defined
   demagnetization implementations.  The Specify initialization string
   for <TT>Oxs_SimpleDemag</TT> is an empty string, i.e.,  { }.

<P>
<B>Example:</B> <TT><B>squarecubic.mif</B></TT>.
</DD>
</DL>

<P>
</LI>
<LI><B>Zeeman Energy</B>
<DL>
<DD><A NAME="UZ"></A><A NAME="5004"></A></DD>
<DT><STRONG>Oxs_UZeeman:<A NAME="html:UZeeman"></A></STRONG></DT>
<DD>Uniform (homogeneous) applied field energy.  This class is frequently
   used for simulating hysteresis loops.  The specify block takes an
   optional <B>multiplier</B> entry, and a required field range list
   <B>Hrange</B>.  The field range list should be a compound list,
   with each sublist consisting of 7 elements: the first 3 denote the
   <B><I>x</I></B>
<!-- MATHEND
 
 -->
, <B><I>y</I></B>
<!-- MATHEND
 
 -->
, and <B><I>z</I></B>
<!-- MATHEND
 
 -->
 components of the start field for the range, the
   next 3 denote the <B><I>x</I></B>
<!-- MATHEND
 
 -->
, <B><I>y</I></B>
<!-- MATHEND
 
 -->
, and <B><I>z</I></B>
<!-- MATHEND
 
 -->
 components of the end field for
   the  range, and the last element specifies the number of (linear) steps
   through the range.  If the step count is 0, then the range consists
   of the start field only.  If the step count is bigger than 0, then
   the start field is skipped over if and only if it is the same field
   that ended the previous range (if any).

<P>
The fields specified in the range entry are nominally in A/m, but
   these values are multiplied by <TT>multiplier</TT>, which may be used to
   effectively change the units.  For example,
   <BLOCKQUOTE><DL><DT>
      <TT>Specify Oxs_UZeeman {</TT>
         <DD><TT> multiplier 795.77472</TT>
         <DD><TT> Hrange {</TT><DL>
              <DD><TT> { 0 0 0 10 0 0 2 }</TT>
              <DD><TT> { 10 0 0 0 0 0 1 }</TT>
         </DL><TT>}</TT>
   <DT><TT>}</TT></DL></BLOCKQUOTE><P>
The applied field steps between 0&nbsp;mT, 5&nbsp;mT, 10&nbsp;mT and back to 0&nbsp;mT,
   for four stages in total.  If the first field in the second range
   sublist was different from the second field in the first range
   sublist, then a step would have been added between those field
   values, so five stages would have resulted.  In this example, note
   that 795.77472=0.001/&micro;<SUB>0</SUB>.

<P>
In addition to the standard energy and field outputs, the
   <TT>Oxs_UZeeman</TT> class provides these four scalar outputs:
   
<UL>
<LI><B>B:</B> Magnitude of the applied field, in
   mT.  This is a non-negative quantity.
</LI>
<LI><B>Bx:</B> Signed amplitude of the <B><I>x</I></B>
<!-- MATHEND
 
 -->
-component
   of the applied field, in mT.
</LI>
<LI><B>By:</B> Signed amplitude of the <B><I>y</I></B>
<!-- MATHEND
 
 -->
-component
   of the applied field, in mT.
</LI>
<LI><B>Bz:</B> Signed amplitude of the <B><I>z</I></B>
<!-- MATHEND
 
 -->
-component
   of the applied field, in mT.
   
</LI>
</UL>

<P>
<B>Examples:</B> <TT><B>sample.mif</B></TT>, <TT><B>cgtest.mif</B></TT>, <TT><B>marble.mif</B></TT>.

<P>
<A NAME="FZ"></A><A NAME="5020"></A></DD>
<DT><STRONG>Oxs_FixedZeeman:</STRONG></DT>
<DD>Non-uniform, non-time varying applied field.
   This can be used to simulate a biasing field.  The specify block
   takes one required parameter, which defines the field, and one
   optional parameter, which specifies a multiplication factor.
      <BLOCKQUOTE><DL><DT>
      <TT>Specify Oxs_FixedZeeman:</TT><I>name</I> <TT>{</TT>
      <DD><TT> field </TT> <I>vector_field_spec</I>
      <DD><TT> multiplier </TT> <I>multiplier</I>
      <DT><TT>}</TT></DL></BLOCKQUOTE><P>
The default value for <I> multiplier</I> is 1.

<P>
<B>Examples:</B> <TT><B>spinvalve.mif</B></TT>, <TT><B>spinvalve-af.mif</B></TT>, <TT><B>yoyo.mif</B></TT>.

<P>
<A NAME="SU"></A><A NAME="5026"></A></DD>
<DT><STRONG>Oxs_ScriptUZeeman:</STRONG></DT>
<DD>Spatially uniform applied field,
   potentially varying as a function of time and stage, determined by a
   Tcl script.  The Specify block has the form
      <BLOCKQUOTE><DL><DT>
      <TT>Specify Oxs_ScriptUZeeman:</TT><I>name</I> <TT>{</TT>
      <DD><TT>script_args {</TT> <I>args_request</I> <TT>}</TT>
      <DD><TT>script </TT> <I>Tcl_script</I>
      <DD><TT>multiplier </TT> <I>multiplier</I>
      <DD><TT>stage_count </TT> <I>number_of_stages</I>
      <DT><TT>}</TT></DL></BLOCKQUOTE><P>
Here <B>script</B> indicates the Tcl script to use.  The script
   is called once each iteration.  Appended to the script are the
   arguments requested by <B>script_args</B>, in the manner
   explained in the <A HREF="MIF_2.1.html#par:supportProcs">User Defined Support Procedures</A>
   section of the MIF&nbsp;2 file format documentation.  The value
   <I> args_request</I> should be a subset of <TT> {stage
   stage_time total_time }</TT>.  If <TT>script_args</TT> is not specified,
   the default argument list is the complete list in the aforementioned
   order.  The units for the time arguments are seconds.

<P>
The return value from the script should be a 6-tuple of numbers,
    {<TT>Hx</TT>, <TT>Hy</TT>, <TT>Hz</TT>, <TT>dHx</TT>, <TT>dHy</TT>, <TT>dHz</TT> },
   representing the applied field and the time derivative of the applied
   field.  The field as a function of time must be differentiable for
   the duration of each stage.  Discontinuities are permitted between
   stages.  If a time evolver is being used, then it is very important
   that the time derivative values are correct; otherwise the evolver
   will not function properly.  This usual symptom of this problem is a
   collapse in the time evolution step size.

<P>
The field and its time derivative are multiplied by the
   <B>multiplier</B> value before use.  The final field value should
   be in A/m; if the Tcl script returns the field in T, then a
   <TT>multiplier</TT> value of 1/&micro;<SUB>0</SUB> (approx. 795774.72) should be
   applied to convert the Tcl result into A/m.  The default value for
   <TT>multiplier</TT> is 1.

<P>
The <B>stage_count</B> parameter informs the
   <A HREF="#sec:oxsDrivers"><TT>Oxs_Driver</TT></A> as to how many stages the
   <TT>Oxs_ScriptUZeeman</TT> object wants.  A value of 0 (the default)
   indicates that the object is prepared for any range of stages.  The
   <TT>stage_count</TT> value given here must be compatible with the
   <A HREF="#html:oxsdriverstagecount"><TT>stage_count</TT> setting in the driver Specify
   block</A>.

<P>
The following example produces a sinusoidally varying field of
   frequency 1 GHz and amplitude 800 A/m, directed along the <B><I>x</I></B>
<!-- MATHEND
 
 -->
-axis.
<BLOCKQUOTE><PRE>
proc SineField { total_time } {
    set PI [expr {4*atan(1.)}]
    set Amp 800.0
    set Freq [expr {1e9*(2*$PI)}]
    set Hx [expr {$Amp*sin($Freq*$total_time)}]
    set dHx [expr {$Amp*$Freq*cos($Freq*$total_time)}]
    return [list $Hx 0 0 $dHx 0 0]
}

Specify Oxs_ScriptUZeeman {
   script_args total_time
   script SineField
}
</PRE>
</BLOCKQUOTE>

<P>
In addition to the standard energy and field outputs, the
   <TT>Oxs_ScriptUZeeman</TT> class provides these four scalar outputs:
   
<UL>
<LI><B>B:</B> Magnitude of the applied field, in
   mT.  This is a non-negative quantity.
</LI>
<LI><B>Bx:</B> Signed amplitude of the <B><I>x</I></B>
<!-- MATHEND
 
 -->
-component
   of the applied field, in mT.
</LI>
<LI><B>By:</B> Signed amplitude of the <B><I>y</I></B>
<!-- MATHEND
 
 -->
-component
   of the applied field, in mT.
</LI>
<LI><B>Bz:</B> Signed amplitude of the <B><I>z</I></B>
<!-- MATHEND
 
 -->
-component
   of the applied field, in mT.
   
</LI>
</UL>

<P>
<B>Examples:</B> <TT><B>acsample.mif</B></TT>, <TT><B>pulse.mif</B></TT>, <TT><B>rotate.mif</B></TT>,
                   <TT><B>varalpha.mif</B></TT>, <TT><B>yoyo.mif</B></TT>.

<P>
<A NAME="TZ"></A><A NAME="5073"></A></DD>
<DT><STRONG>Oxs_TransformZeeman:</STRONG></DT>
<DD>Essentially a combination of the <TT>Oxs_FixedZeeman</TT> and
   <TT>Oxs_ScriptUZeeman</TT> classes, where an applied field is produced
   by applying a spatially uniform, but time and stage varying linear
   transform to a spatially varying but temporally static field.  The
   transform is specified by a Tcl script.

<P>
The Specify block has the form
      <BLOCKQUOTE><DL><DT>
      <TT>Specify Oxs_TransformZeeman:</TT><I>name</I> <TT>{</TT>
      <DD><TT>field </TT> <I>vector_field_spec</I>
      <DD><TT>type </TT> <I>transform_type</I>
      <DD><TT>script </TT> <I>Tcl_script</I>
      <DD><TT>script_args {</TT> <I>args_request</I> <TT>}</TT>
      <DD><TT>multiplier </TT> <I>multiplier</I>
      <DD><TT>stage_count </TT> <I>number_of_stages</I>
      <DT><TT>}</TT></DL></BLOCKQUOTE><P>
The <B>field</B> specified by <I> vector_field_spec</I> is
   evaluated during problem initialization and held throughout the life
   of the problem.  On each iteration, the specified Tcl    <B>script</B> is called once.  Appended to the script are the
   arguments requested by <B>script_args</B>, as explained in the
   <A HREF="MIF_2.1.html#par:supportProcs">User Defined Support Procedures</A> section of the
   MIF&nbsp;2 file format documentation.  The value for <TT>script_args</TT>
   should be a subset of <TT> {stage stage_time total_time }</TT>.
   The default value for <TT>script_args</TT> is the complete list in the
   aforementioned order.  The time arguments are specified in seconds.

<P>
The script return value should define a 3x3 linear transform and its
   time derivative.  The transform must be differentiable with respect
   to time throughout each stage, but is allowed to be discontinuous
   between stages.  As noted in the <TT>Oxs_ScriptUZeeman</TT>
   documentation, it is important that the derivative information be
   correct.  The transform is applied pointwise to the fixed
   field obtained from <I> vector_field_spec</I>, which is
   additionally scaled by <I> multiplier</I>.  The
   <B>multiplier</B> entry is optional, with default value 1.0.

<P>
The <B>type</B> <I> transform_type</I> value declares the
   format of the result returned from the Tcl script.  Recognized
   formats are <TT>identity</TT>, <TT>diagonal</TT>, <TT>symmetric</TT> and
   <TT>general</TT>.  The most flexible is <TT>general</TT>, which indicates
   that the return from the Tcl script is a list of 18 numbers,
   defining a general 3x3 matrix and its 3x3 matrix of time derivatives.
   The matrices are specified in row-major order, i.e., <B><I>M</I><SUB>1, 1</SUB></B>
<!-- MATHEND
 
 -->
,
   <B><I>M</I><SUB>1, 2</SUB></B>
<!-- MATHEND
 
 -->
, <B><I>M</I><SUB>1, 3</SUB></B>
<!-- MATHEND
 
 -->
, <B><I>M</I><SUB>2, 1</SUB></B>
<!-- MATHEND
 
 -->
, <B><I>M</I><SUB>2, 2</SUB></B>
<!-- MATHEND
 
 -->
, ....  Of course, this
   is a long list to construct; if the desired transform is symmetric or
   diagonal, then the <TT>type</TT> may be set accordingly to reduce the
   size of the Tcl result string.  Scripts of the <TT>symmetric</TT> type
   return 12 numbers, the 6 upper diagonal entries in row-major order,
   i.e., <B><I>M</I><SUB>1, 1</SUB></B>
<!-- MATHEND
 
 -->
, <B><I>M</I><SUB>1, 2</SUB></B>
<!-- MATHEND
 
 -->
, <B><I>M</I><SUB>1, 3</SUB></B>
<!-- MATHEND
 
 -->
, <B><I>M</I><SUB>2, 2</SUB></B>
<!-- MATHEND
 
 -->
, <B><I>M</I><SUB>2, 3</SUB></B>
<!-- MATHEND
 
 -->
,
   <B><I>M</I><SUB>3, 3</SUB></B>
<!-- MATHEND
 
 -->
, for both the transformation matrix and its time
   derivative.  Use the <TT>diagonal</TT> type for diagonal matrices, in
   which case the Tcl script result should be a list of 6 numbers.

<P>
The simplest <I> transform_type</I> is <TT>identity</TT>, which is the
   default.  This identifies the transform as the identity matrix, which
   means that effectively no transform is applied, aside from the
   <TT>multiplier</TT> option which is still active.  For the <TT>identity</TT>
   transform type, <TT>script</TT> and <TT>script_args</TT> should not be
   specified, and <TT>Oxs_TransformZeeman</TT> becomes a clone of the
   <TT>Oxs_FixedZeeman</TT> class.

<P>
The following example produces a 1000 A/m field that rotates in the
   <B><I>xy</I></B>
<!-- MATHEND
 
 -->
-plane at a frequency of 1 GHz:
<BLOCKQUOTE><PRE>
proc Rotate { freq stage stagetime totaltime } {
   global PI
   set w [expr {$freq*2*$PI}]
   set ct [expr {cos($w*$totaltime)}]
   set mct [expr {-1*$ct}]      ;# "mct" is "minus cosine (w)t"
   set st [expr {sin($w*$totaltime)}]
   set mst [expr {-1*$st}]      ;# "mst" is "minus sine (w)t"
   return [list  $ct $mst  0 \
                 $st $ct   0 \
                   0   0   1 \
                 [expr {$w*$mst}] [expr {$w*$mct}] 0 \
                 [expr {$w*$ct}]  [expr {$w*$mst}] 0 \
                        0                0         0]
}

Specify Oxs_TransformZeeman {
  type general
  script {Rotate 1e9}
  field {0 1000. 0}
}
</PRE>
</BLOCKQUOTE>
This particular effect could be obtained using the
<TT>Oxs_ScriptUZeeman</TT> class, because the <TT>field</TT> is uniform.
But the field was taken uniform only to simplify the example.  The
<I> vector_field_spec</I> may be any <A HREF="#sec:oxsFieldObjects">Oxs vector field
object</A>.  For
example, the base field could be large in the center of the sample, and
decay towards the edges.  In that case, the above example would generate
an applied rotating field that is concentrated in the center of the
sample.

<P>
The <B>stage_count</B> parameter informs the
<A HREF="#sec:oxsDrivers"><TT>Oxs_Driver</TT></A> as to how many stages the
<TT>Oxs_TransformZeeman</TT> object wants.  A value of 0 (the default)
indicates that the object is prepared for any range of stages.  The
<TT>stage_count</TT> value given here must be compatible with the
<A HREF="#html:oxsdriverstagecount"><TT>stage_count</TT> setting in the driver Specify
block</A>.

<P>
<B>Examples:</B> <TT><B>sample2.mif</B></TT>, <TT><B>tickle.mif</B></TT>, <TT><B>rotatecenter.mif</B></TT>.

<P>
<A NAME="SZ"></A><A NAME="5146"></A></DD>
<DT><STRONG>Oxs_StageZeeman:</STRONG></DT>
<DD>The <TT>Oxs_StageZeeman</TT> class provides spatially varying applied
   fields that are updated once per stage.  In its general form, the
   field at each stage is provided by an <A HREF="#sec:oxsFieldObjects">Oxs vector field
   object</A>
   determined by a user supplied Tcl script.  There is also a
   simplified interface that accepts a list of <A HREF="Vector_Field_File_Format_OV.html#sec:vfformats">vector
   field files</A>, one per
   stage, that are used to specify the applied field.

<P>
The Specify block takes the form
      <BLOCKQUOTE><DL><DT>
      <TT>Specify Oxs_StageZeeman:</TT><I>name</I> <TT>{</TT>
      <DD><TT>script </TT> <I>Tcl_script</I>
      <DD><TT>files </TT> <TT>{</TT> <I>list_of_files</I> <TT>}</TT>
      <DD><TT>stage_count </TT> <I>number_of_stages</I>
      <DD><TT>multiplier </TT> <I>multiplier</I>
      <DT><TT>}</TT></DL></BLOCKQUOTE><P>
The initialization string should specify either <TT>script</TT> or
   <TT>files</TT>, but not both.  If a <B>script</B> is specified,
   then each time a new stage is started in the simulation, a Tcl    command is formed by appending to <I> Tcl_script</I> the 0-based
   integer stage number.  This command should return a reference to an
   <TT>Oxs_VectorField</TT> object, as either the instance name of an
   object defined via a top-level Specify block elsewhere in the
   MIF file, or as a two item list consisting of the name of an
   <TT>Oxs_VectorField</TT> class and an appropriate initialization string.
   In the latter case the <TT>Oxs_VectorField</TT> object will be created
   as a temporary object via an inlined Specify call.

<P>
The following example should help clarify the use of the <TT>script</TT>
   parameter.
<BLOCKQUOTE><PRE>
proc SlidingField { xcutoff xrel yrel zrel } {
   if {$xrel&gt;$xcutoff} { return [list 0. 0. 0.] }
   return [list 2e4 0. 0.]
}

proc SlidingFieldSpec { stage } {
  set xcutoff [expr {double($stage)/10.}]
  set spec Oxs_ScriptVectorField
  lappend spec [subst {
      atlas :atlas
      script {SlidingField $xcutoff}
   }]
   return $spec
}

Specify Oxs_StageZeeman {
  script SlidingFieldSpec
  stage_count 11
}
</PRE>
</BLOCKQUOTE>

<P>
The <TT>SlidingFieldSpec</TT> proc is used to generate the initialization
   string for an <TT>Oxs_ScriptVectorField</TT> vector field object, which
   in turn uses the <TT>SlidingField</TT> proc to specify the applied field
   on a position-by-position basis.  The resulting field will be
   2e4 A/m in the positive x-direction at
   all points with relative x-coordinate larger than <TT>$stage/10.</TT>,
   and 0 otherwise.  <TT>$stage</TT> is the stage index, which here is
   one of 0, 1, ..., 10.  For example, if <TT>$stage</TT> is 5, then the
   left half of the sample will see a 2e4
   A/m field directed to the right, and the right half of the sample
   will see none.  The return value from <TT>SlidingFieldSpec</TT> in this
   case will be
<BLOCKQUOTE><PRE>
Oxs_ScriptVectorField {
   atlas :atlas
   script {SlidingField 0.5}
}
</PRE>
</BLOCKQUOTE>
   The <code>:atlas</code> reference is to an <TT>Oxs_Atlas</TT> object defined
   elsewhere in the MIF file.

<P>
The <B>stage_count</B> parameter lets the
   <A HREF="#sec:oxsDrivers"><TT>Oxs_Driver</TT></A> know how many stages the
   <TT>Oxs_StageZeeman</TT> object wants.  A value of 0 indicates that the
   object is prepared for any range of stages.  Zero is the default
   value for <TT>stage_count</TT> when using the <I> Tcl_script</I>
   interface.  The <TT>stage_count</TT> value given here must be compatible
   with the <A HREF="#html:oxsdriverstagecount"><TT>stage_count</TT> setting in the driver Specify
   block</A>.

<P>
The example above made use of two scripts, one to specify the
   <TT>Oxs_VectorField</TT> object, and one used internally by the
   <TT>Oxs_ScriptVectorField</TT> object.  But any <TT>Oxs_VectorField</TT>
   class may be used, as in the next example.
<BLOCKQUOTE><PRE>
proc FileField { stage } {
  set filelist { field-a.ohf field-b.ohf field-c.ohf }
  set spec Oxs_FileVectorField
  lappend spec [subst {
      atlas :atlas
      file [lindex $filelist $stage]
   }]
   return $spec
}

Specify Oxs_StageZeeman {
  script FileField
  stage_count 3
}
</PRE>
</BLOCKQUOTE>
   The <TT>FileField</TT> proc yields a specification for an
   <TT>Oxs_FileVectorField</TT> object that loads one of three files,
   <TT>field-a.ohf</TT>, <TT>field-b.ohf</TT>, or <TT>field-c.ohf</TT>, depending on
   the stage number.

<P>
Specifying applied fields from a sequence of files is common enough
   to warrant a simplified interface.  This is the purpose of the
   <B>files</B> parameter:
<BLOCKQUOTE><PRE>
Specify Oxs_StageZeeman {
  files { field-a.ohf field-b.ohf field-c.ohf }
}
</PRE>
</BLOCKQUOTE>
   This is essentially equivalent to the preceding example, with two
   differences.  First, <TT>stage_count</TT> is not needed because
   <TT>Oxs_StageZeeman</TT> knows the length of the list of files.  You may
   specify <TT>stage_count</TT>, but the default value is the length of the
   <TT>files</TT> list.  This is in contrast to the default value
   of 0 when using the <TT>script</TT> interface.  If <TT>stage_count</TT> is
   set larger than the file list, then the last file is repeated as
   necessary to reach the specified size.

<P>
The second difference is that no <TT>Oxs_Atlas</TT> is specified when
   using the <TT>files</TT> interface.  The <TT>Oxs_FileVectorField</TT> object
   spatially scales the field read from the file to match a specified
   volume.  Typically a volume is specified by explicit reference to an
   atlas, but with the <TT>files</TT> interface to <TT>Oxs_StageZeeman</TT> the
   file fields are implicitly scaled to match the whole of the meshed
   simulation volume.  This is the most common case; to obtain a
   different spatial scaling use the <TT>script</TT> interface as
   illustrated above with a different atlas or an explicit x/y/z-range
   specification.

<P>
The <I> list_of_files</I> value is interpreted as a
   <A HREF="MIF_2.1.html#par:groupedLists"><I>grouped list</I></A>.  

<P>
The remaining <TT>Oxs_StageZeeman</TT> parameter is
   <B>multiplier</B>.  The value of this parameter is applied as a
   scale factor to the field magnitude on a point-by-point basis.  For
   example, if the field returned by the <TT>Oxs_VectorField</TT> object
   were in Oe, instead of the required A/m, then <TT>multiplier</TT> could
   be set to 79.5775 to perform the conversion.  The direction of the
   applied field can be reversed by supplying a negative <TT>multiplier</TT>
   value.

<P>
In addition to the standard energy and field outputs, the
   <TT>Oxs_StageZeeman</TT> class provides these four scalar outputs:
   
<UL>
<LI><B>B max:</B> Pointwise maximum magnitude of the applied
     field, in mT.  This is a non-negative quantity;
     
B&nbsp;max&nbsp;=&nbsp;[(Bx&nbsp;max)<SUP>2</SUP>+(By&nbsp;max)<SUP>2</SUP>+(Bz&nbsp;max)<SUP>2</SUP>]<SUP>1/2</SUP>.
</LI>
<LI><B>Bx max:</B> Signed value of the <B><I>x</I></B>
<!-- MATHEND
 
 -->
-component of the applied
     field at the point of maximum applied field magnitude, in mT.
</LI>
<LI><B>By max:</B> Signed value of the <B><I>y</I></B>
<!-- MATHEND
 
 -->
-component of the applied
     field at the point of maximum applied field magnitude, in mT.
</LI>
<LI><B>Bz max:</B> Signed value of the <B><I>z</I></B>
<!-- MATHEND
 
 -->
-component of the applied
     field at the point of maximum applied field magnitude, in mT.
   
</LI>
</UL>

<P>

   <B>Examples:</B> <TT><B>sliding.mif</B></TT>, <TT><B>slidingproc.mif</B></TT>,
                      <TT><B>rotatestage.mif</B></TT>, <TT><B>rotatecenterstage.mif</B></TT>.

<P>
</DD>
</DL>
</LI>
</UL>

<P>

<H3><A NAME="SECTION00083400000000000000"></A><A NAME="sec:oxsEvolvers"></A>
<BR>
Evolvers
</H3>
Evolvers are responsible for updating the magnetization configuration
from one step to the next.  There are two types of evolvers,
<I>time evolvers</I>, which track Landau-Lifshitz-Gilbert dynamics,
and <I>minimization evolvers</I>, which locate local minima in the
energy surface through direct minimization techniques.  Evolvers are
controlled by <A HREF="#sec:oxsDrivers">drivers</A>, and must be matched with the appropriate
driver type, i.e., time evolvers must be paired with
<A HREF="#item:TimeDriver">time drivers</A>, and
minimization evolvers must be paired with <A HREF="#html:MinDriver">minimization
drivers</A>.  The drivers hand a magnetization
configuration to the evolvers with a request to advance the
configuration by one <I>step</I> (also called an <I>iteration</I>).
It is the role of the drivers, not the evolvers, to determine when a
simulation stage or run is complete.  Specify blocks for evolvers
contain parameters to control all aspects of individual stepwise
evolution, but stopping criteria are communicated in the Specify block
of the driver, not the evolver.

<P>
There are currently three time evolvers and one minimization evolver in the
standard OOMMF distribution.  The time evolvers are
<A HREF="#html:EulerEvolve"><TT>Oxs_EulerEvolve</TT></A>,
<A HREF="#html:RungeKuttaEvolve"><TT>Oxs_RungeKuttaEvolve</TT></A>, and
<A HREF="#html:SpinXferEvolve"><TT>Oxs_SpinXferEvolve</TT></A>.
The minimization evolver is
<A HREF="#html:CGEvolve"><TT>Oxs_CGEvolve</TT></A>.
<DL>
<DD><A NAME="EE"></A><A NAME="5272"></A></DD>
<DT><STRONG>Oxs_EulerEvolve:<A NAME="html:EulerEvolve"></A></STRONG></DT>
<DD>Time evolver implementing a simple first order forward Euler method with
step size control on the Landau-Lifshitz
ODE<A NAME="5274"></A>&nbsp;[<A
 HREF="bibliography.html#gilbert55">10</A>,<A
 HREF="bibliography.html#landau35">12</A>]:
<BR>
<P></P>
<DIV ALIGN="CENTER">
<A NAME="eq:oxsllode"></A><!-- MATH
 \begin{equation}
\htmlimage{antialias}
  \frac{d\textbf{M}}{dt} = -|\bar{\gamma}|\,\textbf{M}\times\textbf{H}_{\rm eff}
   - \frac{|\bar{\gamma}|\alpha}{M_s}\,
     \textbf{M}\times\left(\textbf{M}\times\textbf{H}_{\rm eff}\right),
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><BIG><A NAME="eq:oxsllode"></A><IMG
 WIDTH="397" HEIGHT="52" BORDER="0"
 SRC="img20.gif"
 ALT="\begin{displaymath}
\frac{d\textbf{M}}{dt} = -\vert\bar{\gamma}\vert\,\textbf{M...
...tbf{M}\times\left(\textbf{M}\times\textbf{H}_{\rm eff}\right),
\end{displaymath}"></BIG></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(2)</TD></TR>
</TABLE>
<!-- MATHEND
 
 -->
</DIV>
where <!-- MATH
 $\textbf{M}$
 -->
<B><B>M</B></B>
<!-- MATHEND
 
 -->
 is the magnetization, <!-- MATH
 $\textbf{H}_{\rm eff}$
 -->
<B><B>H</B><SUB>eff</SUB></B>
<!-- MATHEND
 
 -->
 is the effective
field, <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\bar{\gamma}\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img22.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\bar{\gamma}\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
 is the Landau-Lifshitz gyromagnetic ratio, and
<!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\alpha\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="14" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img24.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\alpha\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
 is the damping constant. The Gilbert form

<P></P>
<DIV ALIGN="CENTER">
<A NAME="eq:oxsllgode"></A><!-- MATH
 \begin{equation}
\htmlimage{antialias}
  \frac{d\textbf{M}}{dt} = -|\gamma|\,\textbf{M}\times\textbf{H}_{\rm eff}
   + \frac{\alpha}{M_s}
     \left(\textbf{M}\times\frac{d\textbf{M}}{dt}\right),
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><BIG><A NAME="eq:oxsllgode"></A><IMG
 WIDTH="355" HEIGHT="57" BORDER="0"
 SRC="img25.gif"
 ALT="\begin{displaymath}
\frac{d\textbf{M}}{dt} = -\vert\gamma\vert\,\textbf{M}\time...
...ha}{M_s}
\left(\textbf{M}\times\frac{d\textbf{M}}{dt}\right),
\end{displaymath}"></BIG></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(3)</TD></TR>
</TABLE>
<!-- MATHEND
 
 -->
</DIV>
where <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
 is the Gilbert gyromagnetic ratio, is
mathematically equivalent to the Landau-Lifshitz form under the
relation <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma = (1+\alpha^2)\,\bar{\gamma}\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="106" HEIGHT="22" ALIGN="BOTTOM" BORDER="0"
 SRC="img29.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma = (1+\alpha^2)\,\bar{\gamma}\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
.

<P>
The Specify block has the form
   <BLOCKQUOTE><DL><DT>
   <TT>Specify Oxs_EulerEvolve:</TT><I>name</I> <TT>{</TT>
   <DD><TT> alpha </TT>
   <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\alpha\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="14" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img24.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\alpha\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
   
   <DD><TT> gamma_LL </TT>
   <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\bar{\gamma}\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img22.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\bar{\gamma}\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
   
   <DD><TT> gamma_G </TT>
   <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
   
   <DD><TT> do_precess </TT> <I>precess</I>
   <DD><TT> min_timestep </TT> <I>minimum_stepsize</I>
   <DD><TT> max_timestep </TT> <I>maximum_stepsize</I>
   <DD><TT> fixed_spins {</TT><DL>
       <DD><I>atlas_spec</I>
       <DD><I>region1</I><TT>&nbsp;</TT><I>region2</I><TT> ...</TT>
       <DT><TT>}</TT></DL>
   <DD><TT> start_dm </TT>
   <!-- MATH
 $\Delta \textbf{m}$
 -->
<B><IMG
 WIDTH="18" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img30.gif"
 ALT="$ \Delta$"><B>m</B></B>
<!-- MATHEND
 
 -->
   
   <DD><TT> error_rate </TT> <I>rate</I>
   <DD><TT> absolute_step_error </TT> <I>abs_error</I>
   <DD><TT> relative_step_error </TT> <I>rel_error</I>
   <DD><TT> step_headroom </TT> <I>headroom</I>
   <DT><TT>}</TT></DL></BLOCKQUOTE><P>
All the entries have default values, but the ones most commonly adjusted
are listed first.

<P>
The options <B>alpha</B>, <B>gamma_LL</B> and
<B>gamma_G</B> are as in the Landau-Lifshitz-Gilbert ODE
(<A HREF="#eq:oxsllode">2</A>), (<A HREF="#eq:oxsllgode">3</A>), where the units on
<!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\bar{\gamma}\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img22.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\bar{\gamma}\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
 and <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
 are m/A<B><SUP> . </SUP></B>
<!-- MATHEND
 
 -->
s and
<!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\alpha\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="14" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img24.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\alpha\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
 is dimensionless.  At most one of
<!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\bar{\gamma}\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img22.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\bar{\gamma}\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
 and <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
 should be specified.  If
neither is specified, then the default is<!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
<!-- MATH
 $=2.211\times 10^5$
 -->
<B>= 2.211 <TT>x</TT> 10<SUP>5</SUP></B>
<!-- MATHEND
 
 -->
.
(Because of the absolute value convention adopted on
<!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\bar{\gamma}\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img22.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\bar{\gamma}\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
 and <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
 in
(<A HREF="#eq:oxsllode">2</A>), (<A HREF="#eq:oxsllgode">3</A>), the sign given to the value of
<TT>gamma_LL</TT> or <TT>gamma_G</TT> in the Specify block is
irrelevant.)  The default value for <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\alpha\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="14" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img24.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\alpha\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
 is 0.5, which is
large compared to experimental values, but allows simulations to
converge to equilibria in a reasonable time.  However, for accurate
dynamic studies it is important to assign an appropriate value to
<!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\alpha\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="14" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img24.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\alpha\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
.

<P>
The <B>do_precess</B> value should be either 1 or 0, and determines
whether or not the precession term in the Landau-Lifshitz ODE (i.e., the
first term on the righthand side in (<A HREF="#eq:oxsllode">2</A>)) is used.  If
<I> precess</I> is 0, then precession is disabled and the simulation
evolves towards equilibrium along a steepest descent path.  The default
value is 1.

<P>
The <B>min_timestep</B> and <B>max_timestep</B> parameters provide
soft limits on the size of steps taken by the evolver.  The minimum
value may be overridden by the driver if a smaller step is needed to
meet time based stopping criteria.  The maximum value will be ignored if
a step of that size would produce a magnetization state numerically
indistinguishable from the preceding state.  The units for
<TT>min_timestep</TT> and <TT>max_timestep</TT> are seconds.  Default
values are 0 and <B>10<SUP>-10</SUP></B>
<!-- MATHEND
 
 -->
 respectively.

<P>
The optional <B>fixed_spins</B> entry allows the magnetization in
selected regions of the simulation to be frozen in its initial
configuration.  The value portion of the entry should be a list, with
the first element of the list being either an inline atlas definition
(grouped as a single item), or else the name of a previously defined
atlas.  The remainder of the list are names of regions in that atlas for
which the magnetization is to be be fixed, i.e., <!-- MATH
 $\textbf{M}(t)=\textbf{M}(0)$
 -->
<B><B>M</B>(<I>t</I>) = <B>M</B>(0)</B>
<!-- MATHEND
 
 -->
 for all
time <B><I>t</I></B>
<!-- MATHEND
 
 -->
 for all points in the named regions.  Fields and energies are
computed and reported normally across these regions.  Although any atlas
may be used, it is frequently convenient to set up an atlas with special
regions defined expressly for this purpose.

<P>
The stepsize for the first candidate iteration in the problem run is
selected so that the maximum change in the normalized (i.e., unit)
magnetization <!-- MATH
 $\textbf{m}$
 -->
<B><B>m</B></B>
<!-- MATHEND
 
 -->
 is the value specified by <B>start_dm</B>.  The
units are degrees, with default value 0.01.

<P>
The four remaining entries, <B>error_rate</B>,
<B>absolute_step_error</B>, <B>relative_step_error</B>, and
<B>step_headroom</B>, control fine points of stepsize selection,
and are intended for advance use only.  Given normalized magnetization
<!-- MATH
 $\textbf{m}_i(t)$
 -->
<B><B>m</B><SUB>i</SUB>(<I>t</I>)</B>
<!-- MATHEND
 
 -->
 at time <B><I>t</I></B>
<!-- MATHEND
 
 -->
 and position <B><I>i</I></B>
<!-- MATHEND
 
 -->
, and candidate magnetization
<!-- MATH
 $\textbf{m}_i(t+\Delta t)$
 -->
<B><B>m</B><SUB>i</SUB>(<I>t</I> + <IMG
 WIDTH="18" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img30.gif"
 ALT="$ \Delta$"><I>t</I>)</B>
<!-- MATHEND
 
 -->
 at time <!-- MATH
 $t+\Delta t$
 -->
<B><I>t</I> + <IMG
 WIDTH="18" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img30.gif"
 ALT="$ \Delta$"><I>t</I></B>
<!-- MATHEND
 
 -->
, the error at position <B><I>i</I></B>
<!-- MATHEND
 
 -->
 is
estimated to be
<!-- MATH
 \begin{displaymath}
\htmlimage{antialias}
\mbox{Error}_i =
  \left|\dot{\textbf{m}}_i(t+\Delta t) - \dot{\textbf{m}}_i(t)\right|\Delta t
      \,/\,2,
\end{displaymath}
 -->
<P ALIGN="CENTER"><IMG
 WIDTH="313" HEIGHT="35" BORDER="0"
 SRC="img31.gif"
 ALT="\begin{displaymath}
\mbox{Error}_i =
\left\vert\dot{\textbf{m}}_i(t+\Delta t) - \dot{\textbf{m}}_i(t)\right\vert\Delta t
\,/\,2,
\end{displaymath}"></P>
<!-- MATHEND
 
 -->
where the derivative with respect to time, <!-- MATH
 $\dot{\textbf{m}}$
 -->
<B><IMG
 WIDTH="20" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img32.gif"
 ALT="$ \dot{{\textbf{m}}}$"></B>
<!-- MATHEND
 
 -->
, is computed
using the Landau-Lifshitz ODE (<A HREF="#eq:oxsllode">2</A>).  First order methods
essentially assume that <!-- MATH
 $\dot{\textbf{m}}$
 -->
<B><IMG
 WIDTH="20" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img32.gif"
 ALT="$ \dot{{\textbf{m}}}$"></B>
<!-- MATHEND
 
 -->
 is constant on the interval
<!-- MATH
 $[t,t+\Delta t]$
 -->
<B>[<I>t</I>, <I>t</I> + <IMG
 WIDTH="18" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img30.gif"
 ALT="$ \Delta$"><I>t</I>]</B>
<!-- MATHEND
 
 -->
; the above formula uses the difference in <!-- MATH
 $\dot{\textbf{m}}$
 -->
<B><IMG
 WIDTH="20" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img32.gif"
 ALT="$ \dot{{\textbf{m}}}$"></B>
<!-- MATHEND
 
 -->
at the endpoints of the interval to estimate (guess) how untrue that
assumption is.

<P>
A candidate step is accepted if the maximum error across all positions
<B><I>i</I></B>
<!-- MATHEND
 
 -->
 is smaller than <TT>absolute_step_error</TT>,
<TT>error_rate</TT><!-- MATH
 $\,\times\,\Delta t$
 -->
<B>&nbsp; <TT>x</TT> &nbsp;<IMG
 WIDTH="18" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img30.gif"
 ALT="$ \Delta$"><I>t</I></B>
<!-- MATHEND
 
 -->
, and
<TT>relative_step_error</TT><!-- MATH
 $\,\times\,|\dot{\textbf{m}}_{\rm
max}|\Delta t$
 -->
<B>&nbsp; <TT>x</TT> &nbsp;|<IMG
 WIDTH="43" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img33.gif"
 ALT="$ \dot{{\textbf{m}}}_{{\rm
max}}^{}$">|<IMG
 WIDTH="18" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img30.gif"
 ALT="$ \Delta$"><I>t</I></B>
<!-- MATHEND
 
 -->
, where <!-- MATH
 $|\dot{\textbf{m}}_{\rm max}|$
 -->
<B>|<IMG
 WIDTH="43" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img33.gif"
 ALT="$ \dot{{\textbf{m}}}_{{\rm
max}}^{}$">|</B>
<!-- MATHEND
 
 -->
 is the maximum value of
<!-- MATH
 $|\dot{\textbf{m}}_i|$
 -->
<B>|<IMG
 WIDTH="24" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.gif"
 ALT="$ \dot{{\textbf{m}}}_{i}^{}$">|</B>
<!-- MATHEND
 
 -->
 across all <B><I>i</I></B>
<!-- MATHEND
 
 -->
 at time <B><I>t</I></B>
<!-- MATHEND
 
 -->
.  If the step is rejected,
then a smaller stepsize is computed that appears to pass the above
tests, and a new candidate step is proposed using that smaller stepsize
times <TT>step_headroom</TT>.  Alternatively, if the step is accepted,
then the error information is used to determine the stepsize for the
next step, modified in the same manner by <TT>step_headroom</TT>.

<P>
The error calculated above is in terms of unit magnetizations, so the
natural units are radians or radians/second.  Inside the Specify block,
however, the <TT>error_rate</TT> and <TT>absolute_step_error</TT> are
specified in degrees/nanosecond and degrees, respectively; they are
converted appropriately inside the code before use.  The
<TT>relative_step_error</TT> is a dimensionless quantity, representing a
proportion between 0 and 1.  The error check controlled by each of these
three quantities may be disabled by setting the quantity value to -1.
They are all optional, with default values of -1 for <TT>error_rate</TT>,
0.2 for <TT>absolute_step_error</TT>, and 0.2 for
<TT>relative_step_error</TT>.

<P>
The <TT>headroom</TT> quantity should lie in the range <B>(0, 1)</B>
<!-- MATHEND
 
 -->
, and controls
how conservative the code will be in stepsize selection.  If <TT>headroom</TT>
is too large, then much computation time will be lost computing
candidate steps that fail the error control tests.  If <TT>headroom</TT> is
small, then most candidate steps will pass the error control tests, but
computation time may be wasted calculating more steps than are
necessary.  The default value for <TT>headroom</TT> is 0.85.

<P>
In addition to the above error control tests, a candidate step will also
be rejected if the total energy, after adjusting for effects due to any
time varying external field, is found to increase.  In this case the
next candidate stepsize is set to one half the rejected stepsize.

<P>
The <TT>Oxs_EulerEvolve</TT> module provides five scalar, one scalar
field, and three vector field outputs.  The scalar outputs are

<UL>
<LI><B>Max dm/dt:</B> maximum <!-- MATH
 $|d\textbf{m}/dt|$
 -->
<B>| <I>d</I><B>m</B>/<I>dt</I>|</B>
<!-- MATHEND
 
 -->
, in degrees per
   nanosecond; <!-- MATH
 $\textbf{m}$
 -->
<B><B>m</B></B>
<!-- MATHEND
 
 -->
 is the unit magnetization direction.
</LI>
<LI><B>Total energy:</B> in joules.
</LI>
<LI><B>Delta E:</B> change in energy between last step and current
   step, in joules.
</LI>
<LI><B>dE/dt:</B> derivative of energy with respect to time, in
   joules per second.
</LI>
<LI><B>Energy calc count:</B> number of times total energy has been
   calculated.
</LI>
</UL>

<P>
The scalar field output is

<UL>
<LI><B>Total energy density:</B> cellwise total energy density, in
J/m<SUP>3</SUP>.
</LI>
</UL>

<P>
The vector field outputs are

<UL>
<LI><B>Total field:</B> total effective field <!-- MATH
 $\textbf{H}$
 -->
<B><B>H</B></B>
<!-- MATHEND
 
 -->
 in A/m.
</LI>
<LI><B>mxH:</B> torque in A/m; <!-- MATH
 $\textbf{m}$
 -->
<B><B>m</B></B>
<!-- MATHEND
 
 -->
 is the unit magnetization
   direction, <!-- MATH
 $\textbf{H}$
 -->
<B><B>H</B></B>
<!-- MATHEND
 
 -->
 is the total effective field.
</LI>
<LI><B>dm/dt:</B> derivative of spin <!-- MATH
 $\textbf{m}$
 -->
<B><B>m</B></B>
<!-- MATHEND
 
 -->
 with respect to time, in
   radians per second.
</LI>
</UL>

<P>
<B>Example:</B> <TT><B>octant.mif</B></TT>.

<P>
<A NAME="RK"></A><A NAME="5390"></A></DD>
<DT><STRONG>Oxs_RungeKuttaEvolve:<A NAME="html:RungeKuttaEvolve"></A></STRONG></DT>
<DD>Time evolver implementing several Runge-Kutta methods for integrating
the Landau-Lifshitz-Gilbert<A NAME="5392"></A> ODE
(<A HREF="#eq:oxsllode">2</A>), (<A HREF="#eq:oxsllgode">3</A>), with step size control.  In
most cases it will greatly outperform the <TT>Oxs_EulerEvolve</TT> class.
The Specify block has the form
   <BLOCKQUOTE><DL><DT>
   <TT>Specify Oxs_RungeKuttaEvolve:</TT><I>name</I> <TT>{</TT>
   <DD><TT> alpha </TT>
   <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\alpha\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="14" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img24.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\alpha\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
   
   <DD><TT> gamma_LL </TT>
   <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\bar{\gamma}\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img22.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\bar{\gamma}\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
   
   <DD><TT> gamma_G </TT>
   <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
   
   <DD><TT> do_precess </TT> <I>precess</I>
   <DD><TT> allow_signed_gamma </TT> <I>signed_gamma</I>
   <DD><TT> min_timestep </TT> <I>minimum_stepsize</I>
   <DD><TT> max_timestep </TT> <I>maximum_stepsize</I>
   <DD><TT> fixed_spins {</TT><DL>
       <DD><I>atlas_spec</I>
       <DD><I>region1</I><TT>&nbsp;</TT><I>region2</I><TT> ...</TT>
       <DT><TT>}</TT></DL>
   <DD><TT> start_dm </TT>
   <!-- MATH
 $\Delta \textbf{m}$
 -->
<B><IMG
 WIDTH="18" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img30.gif"
 ALT="$ \Delta$"><B>m</B></B>
<!-- MATHEND
 
 -->
   
   <DD><TT> start_dt </TT> <I>start_timestep</I>
   <DD><TT> stage_start </TT> <I>scontinuity</I>
   <DD><TT> error_rate </TT> <I>rate</I>
   <DD><TT> absolute_step_error </TT> <I>abs_error</I>
   <DD><TT> relative_step_error </TT> <I>rel_error</I>
   <DD><TT> energy_precision </TT> <I>eprecision</I>
   <DD><TT> min_step_headroom </TT> <I>min_headroom</I>
   <DD><TT> max_step_headroom </TT> <I>max_headroom</I>
   <DD><TT> reject_goal </TT> <I>reject_proportion</I>
   <DD><TT> method </TT> <I>subtype</I>
   <DT><TT>}</TT></DL></BLOCKQUOTE><P>
Most of these options appear also in the
<A HREF="#html:EulerEvolve"><TT>Oxs_EulerEvolve</TT></A> class.
The repeats have the same meaning as in that class, and the same
default values except for <TT>relative_step_error</TT> and
<TT>error_rate</TT>, which for <TT>Oxs_RungeKuttaEvolve</TT> have the
default values of 0.01 and 1.0, respectively.  Additionally, the
<B>alpha</B>, <B>gamma_LL</B> and <B>gamma_G</B> options
may be initialized using scalar field objects, to allow these material
parameters to vary spatially.

<P>
The <B>allow_signed_gamma</B> parameter is for simulation testing
purposes, and is intended for advanced use only.  There is some lack of
consistency in the literature with respect to the sign of
<!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
.  For this reason the Landau-Lifshitz-Gilbert
equations are presented above (<A HREF="#eq:oxsllode">2</A>, <A HREF="#eq:oxsllgode">3</A>)
using the absolute value of <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
.  This is the
interpretation used if <TT>allow_signed_gamma</TT> is 0 (the default).  If
instead <TT>allow_signed_gamma</TT> is set to 1, then the
Landau-Lifshitz-Gilbert equations are interpreted without the absolute
values and with a sign change on the <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
 terms, i.e., the
default value for <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
 in this case is <!-- MATH
 $-2.211 \times
10^5$
 -->
<B>-2.211 <TT>x</TT> 10<SUP>5</SUP></B>
<!-- MATHEND
 
 -->
 (units are m/A<B><SUP> . </SUP></B>
<!-- MATHEND
 
 -->
s).  In this setting, if <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
is set positive then the spins will precess backwards about the
effective field, and the damping term will force the spins <B>away</B>
from the effective field and increase the total energy.  If you are
experimenting with <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma>0\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="44" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img35.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma&gt;0\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
, you should either set
<!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\alpha<=0\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="58" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img36.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\alpha&lt;=0\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
 to force spins back towards the effective field,
or disable the energy precision control (discussed
<A HREF="#html:oxsrkeprecision">below</A>).

<P>
The two controls <B>min_step_headroom</B> (default value 0.33) and
<B>max_step_headroom</B> (default value 0.95) replace the single
<TT>step_headroom</TT> option in <TT>Oxs_EulerEvolve</TT>.  The effective
<TT>step_headroom</TT> is automatically adjusted by the evolver between the
<I> min_headroom</I> and <I> max_headroom</I> limits to make the
observed reject proportion approach the <B>reject_goal</B> (default
value 0.05).

<P>
The <B>method</B> entry selects a particular Runge-Kutta
implementation.  It should be set to one of <I> rk2</I>,
<I> rk4</I>, <I> rkf54</I>, <I> rkf54m</I>, or <I> rkf54s</I>;
the default value is <I> rkf54</I>.  The <I> rk2</I> and
<I> rk4</I> methods implement canonical second and fourth global order
Runge-Kutta methods[<A
 HREF="bibliography.html#stoer93">18</A>], respectively.  For <I> rk2</I>,
stepsize control is managed by comparing <!-- MATH
 $\dot{\textbf{m}}$
 -->
<B><IMG
 WIDTH="20" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img32.gif"
 ALT="$ \dot{{\textbf{m}}}$"></B>
<!-- MATHEND
 
 -->
 at the middle and
final points of the interval, similar to what is done for stepsize
control for the <TT>Oxs_EulerEvolve</TT> class.  One step of the
<I> rk2</I> method involves 2 evaluations of <!-- MATH
 $\dot{\textbf{m}}$
 -->
<B><IMG
 WIDTH="20" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img32.gif"
 ALT="$ \dot{{\textbf{m}}}$"></B>
<!-- MATHEND
 
 -->
.

<P>
In the <I> rk4</I> method, two successive steps are taken at half the
nominal step size, and the difference between that end point and that
obtained with one full size step are compared.  The error is estimated at
1/15th the maximum difference between these two states.  One step of the
<I> rk4</I> method involves 11 evaluations of <!-- MATH
 $\dot{\textbf{m}}$
 -->
<B><IMG
 WIDTH="20" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img32.gif"
 ALT="$ \dot{{\textbf{m}}}$"></B>
<!-- MATHEND
 
 -->
, but the
end result is that of the 2 half-sized steps.

<P>
The remaining methods, <I> rkf54</I>,  <I> rkf54m</I>,
and <I> rkf54s</I>, are closely related Runge-Kutta-Fehlberg methods
derived by Dormand and Prince[<A
 HREF="bibliography.html#dormand80">7</A>,<A
 HREF="bibliography.html#dormand86">8</A>].  In the
nomenclature of these papers,
<I> rkf54</I> implements RK5(4)7FC,
<I> rkf54m</I> implements RK5(4)7FM, and
<I> rkf54s</I> implements RK5(4)7FS.
All are 5th global order with an embedded 4th order method for stepsize
control.  Each step of these methods requires 6 evaluations of
<!-- MATH
 $\dot{\textbf{m}}$
 -->
<B><IMG
 WIDTH="20" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img32.gif"
 ALT="$ \dot{{\textbf{m}}}$"></B>
<!-- MATHEND
 
 -->
 if the step is accepted, 7 if rejected.  The difference
between the methods involves tradeoffs between stability and error
minimization.  The RK5(4)7FS method has the best stability, RK5(4)7FM
the smallest error, and RK5(4)7FC represents a compromise between the
two.  The default method used by <TT>Oxs_RungeKuttaEvolve</TT> is
RK5(4)7FC.

<P>
<A NAME="html:oxsrkeprecision"></A>The remaining undiscussed entry in the <TT>Oxs_RungeKuttaEvolve</TT>
Specify block is <B>energy_precision</B>.  This should be set to an
estimate of the expected relative accuracy of the energy calculation.
After accounting for any change in the total energy arising from
time-varying applied fields, the energy remainder should decrease from
one step of the LLG ODE to the next.  <TT>Oxs_RungeKuttaEvolve</TT> will
reject a step if the energy remainder is found to increase by more than
that allowed by <I> eprecision</I>.  The default value for
<I> eprecision</I> is 1e-10.  This control
may be disabled by setting <I> eprecision</I> to -1.

<P>
The <TT>Oxs_RungeKuttaEvolve</TT> module provides the same scalar, scalar
field, and vector field outputs as <TT>Oxs_EulerEvolve</TT>.

<P>
<B>Examples:</B> <TT><B>sample.mif</B></TT>, <TT><B>acsample.mif</B></TT>,
                   <TT><B>varalpha.mif</B></TT>, <TT><B>yoyo.mif</B></TT>.

<P>
<A NAME="SX"></A><A NAME="5473"></A></DD>
<DT><STRONG>Oxs_SpinXferEvolve:<A NAME="html:SpinXferEvolve"></A></STRONG></DT>
<DD>Time evolver that integrates an
Landau-Lifshitz-Gilbert<A NAME="5475"></A> ODE augmented with a
spin momentum term [<A
 HREF="bibliography.html#xiao04">21</A>],

<P></P>
<DIV ALIGN="CENTER">
<A NAME="eq:oxsllgspinxfer"></A><!-- MATH
 \begin{equation}
\htmlimage{antialias}
  \frac{d\textbf{m}}{dt} = -|\gamma|\,\textbf{m}\times\textbf{H}_{\rm eff}
   + \alpha
     \left(\textbf{m}\times\frac{d\textbf{m}}{dt}\right)
   + |\gamma|\beta\epsilon
     \left(\textbf{m}\times\textbf{m}_p\times\textbf{m}\right)
   - |\gamma|\beta\epsilon^\prime\,\textbf{m}\times\textbf{m}_p
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><BIG><A NAME="eq:oxsllgspinxfer"></A><IMG
 WIDTH="663" HEIGHT="57" BORDER="0"
 SRC="img37.gif"
 ALT="\begin{displaymath}
\frac{d\textbf{m}}{dt} = -\vert\gamma\vert\,\textbf{m}\time...
...t\gamma\vert\beta\epsilon^\prime\,\textbf{m}\times\textbf{m}_p
\end{displaymath}"></BIG></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(4)</TD></TR>
</TABLE>
<!-- MATHEND
 
 -->
</DIV>
(compare to (<A HREF="#eq:oxsllgode">3</A>)), where
<BR>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{eqnarray*}
\textbf{m}& = & \mbox{reduced magnetization, $\textbf{M}/M_s$} \\
\gamma & = & \mbox{Gilbert gyromagnetic ratio} \\
\beta & = & \left|\frac{\hbar}{\mu_0 e}\right|\frac{J}{t M_s} \\
\textbf{m}_p & = & \mbox{(unit) electron polarization direction} \\
\epsilon & = &
\frac{P\Lambda^2}{(\Lambda^2+1)+(\Lambda^2-1)(\textbf{m}\cdot\textbf{m}_p)} \\
\epsilon^\prime & = & \mbox{secondary spin tranfer term}.
\end{eqnarray*}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><BIG><B>m</B></BIG></TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP><BIG>=</BIG></TD>
<TD ALIGN="LEFT" NOWRAP><BIG><IMG
 WIDTH="268" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.gif"
 ALT="$\displaystyle \mbox{reduced magnetization, $\textbf{M}/M_s$}$"></BIG></TD>
<TD WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><BIG><IMG
 WIDTH="16" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img39.gif"
 ALT="$\displaystyle \gamma$"></BIG></TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP><BIG>=</BIG></TD>
<TD ALIGN="LEFT" NOWRAP><BIG>Gilbert gyromagnetic ratio</BIG></TD>
<TD WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><BIG><IMG
 WIDTH="17" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img40.gif"
 ALT="$\displaystyle \beta$"></BIG></TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP><BIG>=</BIG></TD>
<TD ALIGN="LEFT" NOWRAP><BIG><IMG
 WIDTH="12" HEIGHT="68" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.gif"
 ALT="$\displaystyle \left\vert\vphantom{\frac{\hbar}{\mu_0 e}}\right.$"><IMG
 WIDTH="38" HEIGHT="63" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.gif"
 ALT="$\displaystyle {\frac{{\hbar}}{{\mu_0 e}}}$"><IMG
 WIDTH="12" HEIGHT="68" ALIGN="MIDDLE" BORDER="0"
 SRC="img43.gif"
 ALT="$\displaystyle \left.\vphantom{\frac{\hbar}{\mu_0 e}}\right\vert$"><IMG
 WIDTH="42" HEIGHT="63" ALIGN="MIDDLE" BORDER="0"
 SRC="img44.gif"
 ALT="$\displaystyle {\frac{{J}}{{t M_s}}}$"></BIG></TD>
<TD WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><BIG><B>m</B><SUB>p</SUB></BIG></TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP><BIG>=</BIG></TD>
<TD ALIGN="LEFT" NOWRAP><BIG>(unit) electron polarization direction</BIG></TD>
<TD WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><BIG><IMG
 WIDTH="13" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img45.gif"
 ALT="$\displaystyle \epsilon$"></BIG></TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP><BIG>=</BIG></TD>
<TD ALIGN="LEFT" NOWRAP><BIG><IMG
 WIDTH="251" HEIGHT="67" ALIGN="MIDDLE" BORDER="0"
 SRC="img46.gif"
 ALT="$\displaystyle {\frac{{P\Lambda^2}}{{(\Lambda^2+1)+(\Lambda^2-1)(\textbf{m}\cdot\textbf{m}_p)}}}$"></BIG></TD>
<TD WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><BIG><IMG
 WIDTH="17" HEIGHT="40" ALIGN="MIDDLE" BORDER="0"
 SRC="img47.gif"
 ALT="$\displaystyle \epsilon^{\prime}_{}$"></BIG></TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP><BIG>=</BIG></TD>
<TD ALIGN="LEFT" NOWRAP><BIG>secondary spin tranfer term.</BIG></TD>
<TD WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL">

In the definition of <B><IMG
 WIDTH="14" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img48.gif"
 ALT="$ \beta$"></B>
<!-- MATHEND
 
 -->
, <B><I>e</I></B>
<!-- MATHEND
 
 -->
 is the electron charge in C, <B><I>J</I></B>
<!-- MATHEND
 
 -->
 is
current density in A/m<B><SUP>2</SUP></B>
<!-- MATHEND
 
 -->
, <B><I>t</I></B>
<!-- MATHEND
 
 -->
 is the free layer thickness in meters,
and <B><I>M</I><SUB>s</SUB></B>
<!-- MATHEND
 
 -->
 is the saturation magnetization in A/m.

<P>
The various parameters are defined in the Specify block, which is an
extension of that for the
<A HREF="#html:RungeKuttaEvolve"><TT>Oxs_RungeKuttaEvolve</TT></A> class:
   <BLOCKQUOTE><DL><DT>
   <TT>Specify Oxs_SpinXferEvolve:</TT><I>name</I> <TT>{</TT>
   <DD><TT> alpha </TT>
   <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\alpha\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="14" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img24.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\alpha\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
   
   <DD><TT> gamma_LL </TT>
   <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\bar{\gamma}\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img22.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\bar{\gamma}\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
   
   <DD><TT> gamma_G </TT>
   <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="13" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\gamma\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
   
   <DD><TT> do_precess </TT> <I>precess</I>
   <DD><TT> allow_signed_gamma </TT> <I>signed_gamma</I>
   <DD><TT> min_timestep </TT> <I>minimum_stepsize</I>
   <DD><TT> max_timestep </TT> <I>maximum_stepsize</I>
   <DD><TT> fixed_spins {</TT><DL>
       <DD><I>atlas_spec</I>
       <DD><I>region1</I><TT>&nbsp;</TT><I>region2</I><TT> ...</TT>
       <DT><TT>}</TT></DL>
   <DD><TT> start_dm </TT>
   <!-- MATH
 $\Delta \textbf{m}$
 -->
<B><IMG
 WIDTH="18" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img30.gif"
 ALT="$ \Delta$"><B>m</B></B>
<!-- MATHEND
 
 -->
   
   <DD><TT> stage_start </TT> <I>scontinuity</I>
   <DD><TT> error_rate </TT> <I>rate</I>
   <DD><TT> absolute_step_error </TT> <I>abs_error</I>
   <DD><TT> relative_step_error </TT> <I>rel_error</I>
   <DD><TT> energy_precision </TT> <I>eprecision</I>
   <DD><TT> min_step_headroom </TT> <I>min_headroom</I>
   <DD><TT> max_step_headroom </TT> <I>max_headroom</I>
   <DD><TT> reject_goal </TT> <I>reject_proportion</I>
   <DD><TT> method </TT> <I>subtype</I>
   <DD><TT> P </TT> <I>polarization</I>
   <DD><TT> P_fixed </TT> <I>p_fixed_layer</I>
   <DD><TT> P_free </TT> <I>p_free_layer</I>
   <DD><TT> Lambda </TT>
   <B><IMG
 WIDTH="15" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img49.gif"
 ALT="$ \Lambda$"></B>
<!-- MATHEND
 
 -->
   
   <DD><TT> Lambda_fixed </TT>
   <B><IMG
 WIDTH="15" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img49.gif"
 ALT="$ \Lambda$"></B>
<!-- MATHEND
 
 -->
_fixed_layer
   
   <DD><TT> Lambda_free </TT>
   <B><IMG
 WIDTH="15" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img49.gif"
 ALT="$ \Lambda$"></B>
<!-- MATHEND
 
 -->
_free_layer
   
   <DD><TT> eps_prime </TT> <I>ep</I>
   <DD><TT> J </TT> <I>current_density</I>
   <DD><TT> J_profile </TT> <I>Jprofile_script</I>
   <DD><TT> J_profile_args </TT> <I>Jprofile_script_args</I>
   <DD><TT> mp </TT> <I>p_direction</I>
   <DD><TT> energy_slack </TT> <I>eslack</I>
   <DT><TT>}</TT></DL></BLOCKQUOTE><P>
The options duplicated in the 
<A HREF="#html:RungeKuttaEvolve"><TT>Oxs_RungeKuttaEvolve</TT></A> class
Specify block have the same meaning and default values here, with the
exception of <TT>error_rate</TT>, which for
<TT>Oxs_SpinXferEvolve</TT> has the default value of -1 (i.e., disabled).

<P>
The default values for <B>P</B> and <B>Lambda</B> are 0.4 and 2,
respectively.  If preferred, values for the fixed and free layers may be
instead specified separately, through <B>P_fixed</B>,
<B>P_free</B>, <B>Lambda_fixed</B>, and
<B>Lambda_free</B>.  Otherwise P_fixed = P_free = P and
Lambda_fixed = Lambda_free = Lambda.  Lambda must be larger than or
equal to 1; set Lambda=1 to remove the dependence of
<!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\epsilon\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="11" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img51.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\epsilon\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
 on <!-- MATH
 $\textbf{m}\cdot\textbf{m}_p$
 -->
<B><B>m</B><SUP> . </SUP><B>m</B><SUB>p</SUB></B>
<!-- MATHEND
 
 -->
.  If you want non-zero
<!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\epsilon^\prime\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="14" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img53.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\epsilon^\prime\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
, it is set directly as
<B>eps_prime</B>.

<P>
Current density <B>J</B> and unit polarization direction
<B>mp</B> are required.  The units on J are A/m<B><SUP>2</SUP></B>
<!-- MATHEND
 
 -->
.  Positive J
produces torque that tends to align <!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\textbf{m}\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="20" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img54.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\textbf{m}\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
 towards
<!-- MATH
 $\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\textbf{m}_p\\\rule{1pt}{0pt}\end{array}$}$
 -->
<IMG
 WIDTH="26" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img55.gif"
 ALT="$\mbox{\renewcommand {\arraystretch}{0}$\begin{array}[b]{@{}c@{}}\textbf{m}_p\\ \rule{1pt}{0pt}\end{array}$}$">
<!-- MATHEND
 
 -->
.

<P>
Parameters J, mp, P, Lambda, and eps_prime may all be varied pointwise,
but are fixed with respect to time.  However, J can be multiplied by a
time varying ``profile,'' to model current rise times, pulses, etc.  Use
the <B>J_profile</B> and <B>J_profile_args</B> options to
enable this feature.  The <I> Jprofile_script</I> should be a Tcl script that returns a single scalar.  <I> Jprofile_script_args</I>
should be a subset of <TT> {stage stage_time total_time }</TT>, to
specify arguments appended to <I> Jprofile_script</I> on each time
step.  Default is the entire set, in the order as listed.

<P>
The <TT>Oxs_SpinXferEvolve</TT> module provides the same five scalar
outputs and three vector outputs as <TT>Oxs_RungeKutta</TT>, plus the
scalar output ``average J,'' and the vector field outputs ``Spin
torque'' (which is
<!-- MATH
 $|\gamma|\beta\epsilon\left(\textbf{m}\times\textbf{m}_p\times\textbf{m}\right)$
 -->
<B>|<IMG
 WIDTH="13" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img26.gif"
 ALT="$ \gamma$">|<IMG
 WIDTH="14" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img48.gif"
 ALT="$ \beta$"><IMG
 WIDTH="11" HEIGHT="13" ALIGN="BOTTOM" BORDER="0"
 SRC="img50.gif"
 ALT="$ \epsilon$"><IMG
 WIDTH="12" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img56.gif"
 ALT="$ \left(\vphantom{\textbf{m}\times\textbf{m}_p\times\textbf{m}}\right.$"><B>m</B> <TT>x</TT> <B>m</B><SUB>p</SUB> <TT>x</TT> <B>m</B><IMG
 WIDTH="12" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img57.gif"
 ALT="$ \left.\vphantom{\textbf{m}\times\textbf{m}_p\times\textbf{m}}\right)$"></B>
<!-- MATHEND
 
 -->
) and
``J*mp.''  (Development note: In the case <TT>propagate_mp</TT> is
enabled, <TT>mp</TT> is actually <!-- MATH
 $\Delta_x\partial\textbf{m}/\partial\textbf{x}$
 -->
<B><IMG
 WIDTH="25" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img58.gif"
 ALT="$ \Delta_{x}^{}$"><IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img59.gif"
 ALT="$ \partial$"><B>m</B>/<IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img59.gif"
 ALT="$ \partial$"><B>x</B></B>
<!-- MATHEND
 
 -->
,
where <!-- MATH
 $\textbf{x}$
 -->
<B><B>x</B></B>
<!-- MATHEND
 
 -->
 is the flow direction and <B><IMG
 WIDTH="25" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img58.gif"
 ALT="$ \Delta_{x}^{}$"></B>
<!-- MATHEND
 
 -->
 is the cell dimension
in that direction.)

<P>
The <TT>Oxs_SpinXferEvolve</TT> class does <B>not</B> include any oersted
field arising from the current.  Of course, arbitrary fields simulating
the oersted field may be added separately as Zeeman energy terms.  An
example of this is contained in the <TT><B>spinxfer.mif</B></TT> sample file.

<P>
There are no temperature effects in this evolver, i.e., it is a T = 0 K
code.

<P>
Note also that <!-- MATH
 $\textbf{m}_p$
 -->
<B><B>m</B><SUB>p</SUB></B>
<!-- MATHEND
 
 -->
 is fixed.

<P>
For basic usage, the Specify block can be as simple as
<BLOCKQUOTE><PRE>
Specify Oxs_SpinXferEvolve:evolve {
  alpha 0.014
  J 7.5e12
  mp {1 0 0}
  P 0.4
  Lambda 2
}
</PRE>
</BLOCKQUOTE>

<P>
This class is still in early development; at this time the example files
are located in <TT><B>oommf/app/oxs/local</B></TT> instead of
<TT><B>oommf/app/oxs/examples</B></TT>.

<P>
<B>Examples:</B> <TT><B>spinxfer.mif</B></TT>, <TT><B>spinxfer-miltat.mif</B></TT>,
<TT><B>spinxfer-onespin.mif</B></TT>.

<P>
<A NAME="CG"></A><A NAME="5546"></A></DD>
<DT><STRONG>Oxs_CGEvolve:<A NAME="html:CGEvolve"></A></STRONG></DT>
<DD>The minimization evolver is <TT>Oxs_CGEvolve</TT>, which is an
in-development conjugate gradient minimizer with no preconditioning. The
Specify block has the form
   <BLOCKQUOTE><DL><DT>
   <TT>Specify Oxs_CGEvolve:</TT><I>name</I> <TT>{</TT>
   <DD><TT> gradient_reset_angle </TT> <I>reset_angle</I>
   <DD><TT> gradient_reset_count </TT> <I>count</I>
   <DD><TT> minimum_bracket_step </TT> <I>minbrack</I>
   <DD><TT> maximum_bracket_step </TT> <I>maxbrack</I>
   <DD><TT> line_minimum_angle_precision </TT> <I>min_prec_angle</I>
   <DD><TT> line_minimum_relwidth </TT> <I>relwidth</I>
   <DD><TT> energy_precision </TT> <I>eprecision</I>
   <DD><TT> method </TT> <I>cgmethod</I>
   <DD><TT> fixed_spins {</TT><DL>
       <DD><I>atlas_spec</I>
       <DD><I>region1</I><TT>&nbsp;</TT><I>region2</I><TT> ...</TT>
       <DT><TT>}</TT></DL>
   <DT><TT>}</TT></DL></BLOCKQUOTE><P>
All entries have default values.

<P>
The evolution to an energy minimum precedes by a sequence of line
minimizations.  Each line represents a one dimensional affine subspace
in the <B>3<I>N</I></B>
<!-- MATHEND
 
 -->
 dimensional space of possible magnetization configurations,
where <B><I>N</I></B>
<!-- MATHEND
 
 -->
 is the number of spins in the simulation.  Once a minimum has
been found along a line, a new direction is chosen that is ideally
orthogonal to all preceding directions, but related to the gradient of
the energy taken with respect to the magnetization.  In practice the
line direction sequence cannot be extended indefinitely; the parameters
<B>gradient_reset_angle</B> and <B>gradient_reset_count</B>
control the gradient resetting process.  The first checks the angle
between the new direction and the gradient.  If that angle is larger
than <I> reset_angle</I> (expressed in degrees), then the selected
direction is thrown away, and the conjugate-gradient process is
re-initialized with the gradient direction as the new first direction.
In a similar vein, <I> count</I> specifies the maximum number of line
directions selected before resetting the process.  Because the first
line in the sequence is selected along the gradient direction, setting
<I> count</I> to 1 effectively turns the algorithm into a steepest
descent minimization method.  The default values for
<I> reset_angle</I> and <I> count</I> are 80 degrees and 50,
respectively.

<P>
Once a minimization direction has been selected, the first stage of the
line minimization is to bracket the minimum energy on that line, i.e.,
given a start point on the line&mdash;the location of the minimum from the
previous line minimization&mdash;find another point on the line such that
the energy minimum lies between those two points.  As one moves along
the line, the spins in the simulation rotate, with one spin rotating
faster than (or at least as fast as) all the others.  If the start point
was not the result of a successful line minimization from the previous
stage, then the first bracket attempt step is sized so that the fastest
moving spin rotates through the angle specified by
<B>minimum_bracket_step</B>.  In the more usual case that the
start point is a minimum from the previous line minimization stage, the
initial bracket attempt step size is set to the distance between the
current start point and the start point of the previous line
minimization stage.

<P>
The energy and gradient of the energy are examined at the candidate
bracket point to test if an energy minimum lies in the interval.  If
not, the interval is extended, based on the size of the first bracket
attempt interval and the derivatives of the energy at the interval
endpoints.  This process is continued until either a minimum is
bracketed or the fastest moving spin rotates through the angle specified
by <B>maximum_bracket_step</B>.

<P>
If the bracketing process is successful, then a one dimensional
minimization is carried out in the interval, using both energy and
energy derivative information.  Each step in this process reduces the
width of the bracketing interval.  This process is continued until
the angle between the line direction and the computed energy
gradient is within <B>line_minimum_angle_precision</B> degrees of
orthogonal, and the width of the interval relative to the distance of the
interval from the start point (i.e., the stop point from the previous
line minimization process) is less than
<B>line_minimum_relwidth</B>.  The stop point,
i.e., the effective minimum, is taken to be the endpoint of the final
interval having smaller energy.  The default value for
<I> min_prec_angle</I> is 1 degree, and the default value for
<I> relwidth</I> is 1.  This latter setting effectively disables the
<TT>line_minimum_relwidth</TT> control, which should generally be used
only as a secondary control.

<P>
If the bracketing process is unsuccessful, i.e., the check for bracketed
energy minimum failed at the maximum bracket interval size allowed by
<TT>maximum_bracket_step</TT>, then the maximum bracket endpoint is
accepted as the next point in the minimization iteration.

<P>
Once the line minimum stop point has been selected, the next iteration
begins with selection of a new line direction, as described above,
except in the case where the stop point was not obtained as an actual
minimum, but rather by virtue of satisfying the
<TT>maximum_bracket_step</TT> constraint.  In that case the orthogonal
line sequence is reset, in the same manner as when the
<TT>gradient_reset_angle</TT> or <TT>gradient_reset_count</TT>
controls are triggered, and the next line direction is taken directly
from the energy gradient.

<P>
There are several factors to bear in mind when selecting values for
the parameters <TT>minimum_bracket_step</TT>,
<TT>maximum_bracket_step</TT>, and <TT>line_minimum_relwidth</TT>.
If <TT>minimum_bracket_step</TT> is too small, then it may take a
great many steps to obtain an interval large enough to bracket the
minimum.  If <TT>minimum_bracket_step</TT> is too large, then the
bracket interval will be unnecessarily generous, and many steps may be
required to locate the minimum inside the bracketing interval.  However,
this value only comes into play when resetting the line minimization
direction sequence, so the setting is seldom critical.  It is specified
in degrees, with default value 0.05.

<P>
If <TT>maximum_bracket_step</TT> is too small, then the minima will be
mostly not bracketed, and the minimization will degenerate into a type
of steepest descent method.  On the other hand, if
<TT>maximum_bracket_step</TT> is too large, then the line
minimizations may draw the magnetization far away from a local energy
minimum (i.e., one on the full <B>3<I>N</I></B>
<!-- MATHEND
 
 -->
 dimensional magnetization space),
eventually ending up in a different, more distant minimum.  The value
for <TT>maximum_bracket_step</TT> is specified in degrees, with
default value 10.

<P>
The <TT>line_minimum_angle_precision</TT> and
<TT>line_minimum_relwidth</TT> values determine the precision of the
individual line minimizations, not the total minimization procedure,
which is governed by the stopping criteria specified in the driver's
Specify block.  However, these values are important because the
precision of the line minimizations affects the the line direction
sequence orthogonality.  If both are too coarse, then the selected line
directions will quickly drift away from mutual orthogonality.
Conversely, setting either too fine will
produce additional line minimization steps that do nothing to improve
convergence towards the energy minimum in the full <B>3<I>N</I></B>
<!-- MATHEND
 
 -->
 dimensional
magnetization space.

<P>
The <B>energy_precision</B> parameter estimates the relative
precision of the energy computations.  This is used to introduce a slack
factor into the energy comparisons during the bracketing and line
minimization stages, that is, if the computed energy values at two
points have relative error difference smaller than
<I> eprecision</I>, they are treated as having the same energy.  The
default value for <I> eprecision</I> is 1e-10.  The true precision
will depend primarily on the number of spins in the simulation.  It may
be necessary for very large simulations to increase the
<I> eprecision</I> value.

<P>
The <B>method</B> parameter can be set to either
<TT>Fletcher-Reeves</TT> or <TT>Polak-Ribiere</TT> to specify the
conjugate gradient direction selection algorithm.  The default is
Fletcher-Reeves, which has somewhat smaller memory requirements.

<P>
The last parameter, <B>fixed_spins</B>, performs the same function
as for the <A HREF="#html:EulerEvolve"><TT>Oxs_EulerEvolve</TT></A> class.

<P>
The <TT>Oxs_CGEvolve</TT> module provides nine scalar, one scalar
 field, and two vector field outputs.  The scalar outputs are

<UL>
<LI><B>Max mxHxm:</B> maximum <!-- MATH
 $|\textbf{m}\times\textbf{H}\times\textbf{m}|$
 -->
<B>|<B>m</B> <TT>x</TT> <B>H</B> <TT>x</TT> <B>m</B>|</B>
<!-- MATHEND
 
 -->
, in A/m;
   <!-- MATH
 $\textbf{m}$
 -->
<B><B>m</B></B>
<!-- MATHEND
 
 -->
 is the unit magnetization direction.
</LI>
<LI><B>Total energy:</B> in joules.
</LI>
<LI><B>Delta E:</B> change in energy between last step and current
   step, in joules.
</LI>
<LI><B>Energy calc count:</B> number of times total energy has been
   calculated.
</LI>
<LI><B>Bracket count:</B> total number of attempts required to
   bracket energy minimum during first phase of line minimization
   procedures.
</LI>
<LI><B>Line min count:</B> total number of minimization steps during
   second phase of line minimization procedures (i.e., steps after
   minimum has been bracketed).
</LI>
<LI><B>Cycle count:</B> number of line direction selections.
</LI>
<LI><B>Cycle sub count:</B> number of line direction selections
  since the last gradient direction reset.
</LI>
<LI><B>Conjugate cycle count:</B> number of times the conjugate gradient
   process has been reset to the gradient direction.
</LI>
</UL>

<P>
The scalar field output is

<UL>
<LI><B>Total energy density:</B> cellwise total energy density, in
J/m<SUP>3</SUP>.
</LI>
</UL>

<P>
The vector field outputs are

<UL>
<LI><B>H:</B> total effective field in A/m.
</LI>
<LI><B>mxHxm:</B> in A/m; <!-- MATH
 $\textbf{m}$
 -->
<B><B>m</B></B>
<!-- MATHEND
 
 -->
 is the unit magnetization
   direction.
</LI>
</UL>

<P>
<B>Examples:</B> <TT><B>cgtest.mif</B></TT>, <TT><B>stdprob3.mif</B></TT>, <TT><B>yoyo.mif</B></TT>.

<P>
</DD>
</DL>

<P>

<H3><A NAME="SECTION00083500000000000000"></A><A NAME="sec:oxsDrivers"></A>
<BR>
Drivers
</H3>
While <A HREF="#sec:oxsEvolvers">evolvers</A> are
responsible for moving the simulation forward in individual steps,
<I>drivers</I> coordinate the action of the evolver on the
simulation as a whole, by grouping steps into tasks, stages and runs.

<P>
Tasks are small groups of steps that can be completed without adversely
affecting user interface responsiveness.  Stages are larger units
specified by the MIF problem description; in particular, problem
parameters are not expected to change in a discontinuous manner inside a
stage.  The run is the complete sequence of stages, from problem start to
finish.  The driver detects when stages and runs are finished, using
criteria specified in the MIF problem description, and can enforce
constraints, such as making sure stage boundaries respect time stopping
criteria.

<P>
There are two drivers in Oxs,
<A HREF="#item:TimeDriver"><TT>Oxs_TimeDriver</TT></A>
for controlling time evolvers such as
<A HREF="#html:RungeKuttaEvolve"><TT>Oxs_RungeKuttaEvolve</TT></A>,
and
<A HREF="#html:MinDriver"><TT>Oxs_MinDriver</TT></A>
for controlling minimization evolvers like
<A HREF="#html:CGEvolve"><TT>Oxs_CGEvolve</TT></A>.

<P>
<DL>
<DD><A NAME="TD"></A><A NAME="5628"></A></DD>
<DT><STRONG>Oxs_TimeDriver:<A NAME="item:TimeDriver"></A></STRONG></DT>
<DD>The Oxs time driver is <B>Oxs_TimeDriver</B>.  The specify block has
the form
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_TimeDriver:</TT><I>name</I> <TT>{</TT>
<DD><TT> evolver </TT><I>evolver_spec</I>
<DD><TT> mesh </TT><I>mesh_spec</I>
<DD><TT> Ms </TT> <I>scalar_field_spec</I>
<DD><TT> m0 </TT> <I>vector_field_spec</I>
<DD><TT> stopping_dm_dt </TT><I>torque_criteria</I>
<DD><TT> stopping_time </TT><I>time_criteria</I>
<DD><TT> stage_iteration_limit </TT><I>stage_iteration_count</I>
<DD><TT> total_iteration_limit </TT><I>total_iteration_count</I>
<DD><TT> stage_count </TT><I>number_of_stages</I>
<DD><TT> stage_count_check </TT><I>test</I>
<DD><TT> checkpoint_file </TT> <I>restart_file_name</I>
<DD><TT> checkpoint_interval </TT> <I>checkpoint_minutes</I>
<DD><TT> checkpoint_disposal </TT> <I>cleanup_behavior</I>
<DD><TT> start_iteration </TT> <I>iteration</I>
<DD><TT> start_stage </TT> <I>stage</I>
<DD><TT> start_stage_iteration </TT> <I>stage_iteration</I>
<DD><TT> start_stage_start_time </TT> <I>stage_time</I>
<DD><TT> start_stage_elapsed_time </TT> <I>stage_elapsed_time</I>
<DD><TT> start_last_timestep </TT> <I>timestep</I>
<DD><TT> normalize_aveM_output </TT> <I>aveMflag</I>
<DD><TT> report_max_spin_angle </TT> <I>report_angle</I>
<DD><TT> report_wall_time </TT> <I>report_time</I>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
The first four parameters, <B>evolver</B>, <B>mesh</B>,
<B>Ms</B> and <B>m0</B> provide references to a time evolver, a
mesh, a scalar field and a vector field, respectively.  Here <TT>Ms</TT> is
the pointwise saturation magnetization in A/m, and <TT>m0</TT> is the
initial configuration for the magnetization unit spins, i.e., <!-- MATH
 $|\textbf{m}|=1$
 -->
<B>|<B>m</B>| = 1</B>
<!-- MATHEND
 
 -->
at each point.  These four parameters are required.

<P>
The next group of 3 parameters control stage stopping criteria.  The
<B>stopping_dm_dt</B> value, in degrees per nanosecond, specifies that a
stage should be considered complete when the maximum <!-- MATH
 $|d\textbf{m}/dt|$
 -->
<B>| <I>d</I><B>m</B>/<I>dt</I>|</B>
<!-- MATHEND
 
 -->
 across
all spins drops below this value.  Similarly, the
<B>stopping_time</B> value specifies the maximum ``Simulation
time,'' i.e., the Landau-Lifshitz-Gilbert ODE (<A HREF="#eq:oxsllode">2</A>),
(<A HREF="#eq:oxsllgode">3</A>) time, allowed per stage.  For example, if
<I> time_criteria</I> is
1e-9, then no stage will evolve for more than
1&nbsp;ns.  If there were a total of 5 stages in the simulation, then the
total simulation time would be not more than 5&nbsp;ns.  The third way to
terminate a stage is with a <B>stage_iteration_limit</B>.  This is
a limit on the number of successful evolver steps allowed per stage.  A
stage is considered complete when any one of these three criteria are
met.  Each of the criteria may be either a single value, which is
applied to every stage, or else a
<A HREF="MIF_2.1.html#par:groupedLists"><I>grouped list</I></A>
 of values.  If the
simulation has more stages than a criteria list has entries, then the
last criteria value is applied to all additional stages.  These stopping
criteria all provide a default value of 0, meaning no constraint, but
usually at least one is specified since otherwise there is no automatic
stage termination control.  For quasi-static simulations, a
<TT>stopping_dm_dt</TT> value in the range of 1.0 to 0.01 is reasonable;
the numerical precision of the energy calculations usually makes in not
possible to obtain <!-- MATH
 $|d\textbf{m}/dt|$
 -->
<B>| <I>d</I><B>m</B>/<I>dt</I>|</B>
<!-- MATHEND
 
 -->
 much below 0.001 degree per nanosecond.

<P>
<A NAME="html:oxsdriverstagecount"></A>The <B>total_iteration_limit</B>, <B>stage_count</B> and
<B>stage_count_check</B> parameters involve simulation run
completion conditions.  The default value for the first is 0,
interpreted as no limit, but one may limit the total number of steps
performed in a simulation by specifying a positive integer value here.
The more usual run completion condition is based on the stage count.  If
a positive integer value is specified for <TT>stage_count</TT>, then the
run will be considered complete when the stage count reaches that value.
If <TT>stage_count</TT> is not specified, or is given the value 0, then the
effective <I> number_of_stages</I> value is computed by examining the
length of the stopping criteria lists, and also any other <TT>Oxs_Ext</TT>
object that has stage length expectations, such as
<A HREF="#html:UZeeman"><TT>Oxs_UZeeman</TT></A>.  The longest of these is
taken to be the stage limit value.  Typically these lengths, along with
<TT>stage_count</TT> if specified, will all be the same, and any
differences indicate an error in the MIF file.  Oxs will automatically
test this condition, provided <TT>stage_count_check</TT> is set to 1,
which is the default value.  Stage length requests of 0 or 1 are ignored
in this test, since those lengths are commonly used to represent
sequences of arbitrary length.  At times a short sequence is
intentionally specified that is meant to be implicitly extended to match
the full simulation stage length.  In this case, the stage count check
can be disabled by setting <I> test</I> to 0.

<P>
The checkpoint<A NAME="html:oxsdrivercheckpoint"></A><A NAME="5663"></A><A NAME="5664"></A>
options are used to control the saving of solver state to disk; these
saves are used by the <B>oxsii</B> and <B>boxsi</B> restart feature.
The value of the <B>checkpoint_file</B> option is the name to
use for the solver state file.  The default is
<I>base_file_name</I>.restart.

<P>
Cleanup of the checkpoint file is determined by the setting of
<B>checkpoint_disposal</B>, which should be one of
<I>standard</I> (the default), <I>done_only</I>, or <I>never</I>.
Under the standard setting, the checkpoint file is automatically deleted
upon normal program termination, either because the solver reached the end
of the problem, or because the user interactively terminated the problem
prematurely.  If <I> cleanup_behavior</I> is set to
<TT>done_only</TT>, then the checkpoint file is only deleted if the
problem endpoint is reached.  If <I> cleanup_behavior</I> is
<TT>never</TT>, then OOMMF does not delete checkpoint file; the
user is responsible for deleting this file as she desires.

<P>
The <B>checkpoint_interval</B> value is the time in minutes between
overwrites of the checkpoint file.  No checkpoint file is written until
<I> checkpoint_minutes</I> have elapsed.  Checkpoint writes occur
between solver iterations, so the actual interval time may be somewhat
longer than the specified time.  If <I> checkpoint_minutes</I> is 0,
then each step is saved.  Setting <I> checkpoint_minutes</I> to -1
disables checkpointing.  The default checkpoint interval is 15 minutes.

<P>
The six <B>start_*</B> options control the problem run start point.
These are intended primarily for automatic use by the restart feature.
The default value for each is 0.

<P>
The <B>normalize_aveM_output</B> option is used to control the
scaling and units on the average magnetization components <B><I>M</I><SUB>x</SUB></B>
<!-- MATHEND
 
 -->
, <B><I>M</I><SUB>y</SUB></B>
<!-- MATHEND
 
 -->
and <B><I>M</I><SUB>z</SUB></B>
<!-- MATHEND
 
 -->
 sent as DataTable output (this includes output sent to
<A HREF="Data_Table_Display_mmDataTa.html#sec:mmdatatable"
 NAME="5687"><B>mmDataTable</B></A>,
<A HREF="Data_Graph_Display_mmGraph.html#sec:mmgraph"
 NAME="5692"><B>mmGraph</B></A>, and
<A HREF="Data_Archive_mmArchive.html#sec:mmarchive"
 NAME="5697"><B>mmArchive</B></A>).  If
<I> aveMflag</I> is true (1), then the output values are scaled to lie
in the range <B>[- 1, 1]</B>
<!-- MATHEND
 
 -->
, where the extreme values are obtained only at
saturation (i.e., all the spins are aligned).  If <I> aveMflag</I> is
false (0), then the output is in A/m.  The default setting is 1.

<P>
In the older MIF&nbsp;2.1 format, the driver Specify block supports three
additional values: <B>basename</B>,
<B>scalar_output_format</B>, and
<B>vector_field_output_format</B>.  In the MIF&nbsp;2.2 format
these output controls have been moved into the <TT>SetOptions</TT> block.
See the <A HREF="MIF_2.2.html#html:mif2SetOptions"
 NAME="5708"><TT>SetOptions</TT></A>
documentation for details.

<P>
<TT>Oxs_TimeDriver</TT> provides 12 scalar outputs and 2 vector field
outputs.  The scalar outputs are

<UL>
<LI><B>Stage:</B> current stage number, counting from 0.
</LI>
<LI><B>Stage iteration:</B> number of successful evolver steps
in the current stage.
</LI>
<LI><B>Iteration:</B> number of successful evolver steps in the
current simulation.
</LI>
<LI><B>Simulation time:</B> Landau-Lifshitz-Gilbert evolution
time, in seconds.
</LI>
<LI><B>Last time step:</B> The size of the preceding time step, in
seconds.
</LI>
<LI><B>Mx/mx:</B> magnetization component in the <B><I>x</I></B>
<!-- MATHEND
 
 -->
 direction,
averaged across the entire simulation, in A/m (Mx) or normalized units
(mx), depending on the setting of the <TT>normalize_aveM_output</TT>
option.
</LI>
<LI><B>My/my:</B> magnetization component in the <B><I>y</I></B>
<!-- MATHEND
 
 -->
 direction,
averaged across the entire simulation, in A/m (My) or normalized units
(my), depending on the setting of the <TT>normalize_aveM_output</TT>
option.
</LI>
<LI><B>Mz/mz:</B> magnetization component in the <B><I>z</I></B>
<!-- MATHEND
 
 -->
 direction,
averaged across the entire simulation, in A/m (Mz) or normalized units
(mz), depending on the setting of the <TT>normalize_aveM_output</TT>
option.
</LI>
<LI><B>Max Spin Ang:</B> maximum angle between neighboring spins
having non-zero magnetization <B><I>M</I><SUB>s</SUB></B>
<!-- MATHEND
 
 -->
, measured in degrees.  The definition
of ``neighbor'' depends on the mesh, but for <TT>Oxs_RectangularMesh</TT>
the neighborhood of a point consists of 6 points, those nearest
forward and backward along each of the 3 coordinate axis directions.
</LI>
<LI><B>Stage Max Spin Ang:</B> the largest value of ``Max Spin
Ang'' obtained across the current stage, in degrees.
</LI>
<LI><B>Run Max Spin Ang:</B> the largest value of ``Max Spin
Ang'' obtained across the current run, in degrees.
</LI>
<LI><B>Wall time:</B> Wall clock time, in seconds.
</LI>
</UL>
The three ``Max Spin Ang'' outputs are disabled by default.  In general
one should refer instead to the neighboring spin angle outputs provided
by the exchange energies.  However, for backward compatibility, or for
simulations without any exchange energy terms, the driver spin angle
outputs can be enabled by setting the
<B>report_max_spin_angle</B> option to to 1.

<P>
The ``Wall time'' output is also disabled by default.  It can be enabled
by setting the <B>report_wall_time</B> option to to 1.  It reports
the wall clock time, in seconds, since a system-dependent zero-time.
This output may be useful for performance comparisions and
debugging. (Note: The timestamp for a magnetization state is recorded
when output is first requested for that state; the timestamp is not
directly tied to the processing of the state.)

<P>
The vector field outputs are

<UL>
<LI><B>Magnetization:</B> magnetization vector <!-- MATH
 $\textbf{M}$
 -->
<B><B>M</B></B>
<!-- MATHEND
 
 -->
, in A/m.
</LI>
<LI><B>Spin:</B> unit magnetization <!-- MATH
 $\textbf{m}$
 -->
<B><B>m</B></B>
<!-- MATHEND
 
 -->
.  This output ignores the
<TT>vector_field_output_format</TT> <I> precision</I> setting, instead
always exporting at full precision.
</LI>
</UL>

<P>
<B>Examples:</B> <TT><B>sample.mif</B></TT>, <TT><B>pulse.mif</B></TT>.

<P>
<A NAME="MD"></A><A NAME="5739"></A></DD>
<DT><STRONG>Oxs_MinDriver:<A NAME="html:MinDriver"></A></STRONG></DT>
<DD>The Oxs driver for controlling minimization evolvers is
<B>Oxs_MinDriver</B>.  The specify block has the form
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_MinDriver:</TT><I>name</I> <TT>{</TT>
<DD><TT> evolver </TT><I>evolver_spec</I>
<DD><TT> mesh </TT><I>mesh_spec</I>
<DD><TT> Ms </TT> <I>scalar_field_spec</I>
<DD><TT> m0 </TT> <I>vector_field_spec</I>
<DD><TT> stopping_mxHxm </TT><I>torque_criteria</I>
<DD><TT> stage_iteration_limit </TT><I>stage_iteration_count</I>
<DD><TT> total_iteration_limit </TT><I>total_iteration_count</I>
<DD><TT> stage_count </TT><I>number_of_stages</I>
<DD><TT> stage_count_check </TT><I>test</I>
<DD><TT> checkpoint_file </TT> <I>restart_file_name</I>
<DD><TT> checkpoint_interval </TT> <I>checkpoint_minutes</I>
<DD><TT> checkpoint_disposal </TT> <I>cleanup_behavior</I>
<DD><TT> start_iteration </TT> <I>iteration</I>
<DD><TT> start_stage </TT> <I>stage</I>
<DD><TT> start_stage_iteration </TT> <I>stage_iteration</I>
<DD><TT> start_stage_start_time </TT> <I>stage_time</I>
<DD><TT> start_stage_elapsed_time </TT> <I>stage_elapsed_time</I>
<DD><TT> start_last_timestep </TT> <I>timestep</I>
<DD><TT> normalize_aveM_output </TT> <I>aveMflag</I>
<DD><TT> report_max_spin_angle </TT> <I>report_angle</I>
<DD><TT> report_wall_time </TT> <I>report_time</I>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
These parameters are the same as those described for the
<A HREF="#item:TimeDriver"><TT>Oxs_TimeDriver</TT></A>
class, except that
<B>stopping_mxHxm</B> replaces <TT>stopping_dm_dt</TT>, and there is no
analogue to <TT>stopping_time</TT>.  The value for <TT>stopping_mxHxm</TT> is
in A/m, and may be a
<A HREF="MIF_2.1.html#par:groupedLists"><I>grouped list</I></A>
.
Choice depends on the particulars of the simulation, but typical values
are in the range 10 to 0.1.  Limits in the numerical precision of the
energy calculations usually makes it not possible to obtain
<!-- MATH
 $|\textbf{m}\times\textbf{H}\times\textbf{m}|$
 -->
<B>|<B>m</B> <TT>x</TT> <B>H</B> <TT>x</TT> <B>m</B>|</B>
<!-- MATHEND
 
 -->
 below about 0.01 A/m.  This control can be
disabled by setting it to 0.0.

<P>
As with <TT>Oxs_TimeDriver</TT>, in the older MIF&nbsp;2.1 format this Specify
block supports three additional values: <B>basename</B> to control
output filenames, and output format controls
<B>scalar_output_format</B> and
<B>vector_field_output_format</B>.  In the MIF&nbsp;2.2 format these
output controls have been moved into the <TT>SetOptions</TT> block.  See the
<A HREF="MIF_2.2.html#html:mif2SetOptions"
 NAME="5761"><TT>SetOptions</TT></A>
documentation for details.

<P>
<TT>Oxs_MinDriver</TT> provides 10 scalar outputs and 2 vector
field outputs.  The scalar outputs are

<UL>
<LI><B>Stage:</B> current stage number, counting from 0.
</LI>
<LI><B>Stage iteration:</B> number of successful evolver steps
in the current stage.
</LI>
<LI><B>Iteration:</B> number of successful evolver steps in the
current simulation.
</LI>
<LI><B>Mx/mx:</B> magnetization component in the <B><I>x</I></B>
<!-- MATHEND
 
 -->
 direction,
averaged across the entire simulation, in A/m (Mx) or normalized units
(mx), depending on the setting of the <TT>normalize_aveM_output</TT>
option.
</LI>
<LI><B>My/my:</B> magnetization component in the <B><I>y</I></B>
<!-- MATHEND
 
 -->
 direction,
averaged across the entire simulation, in A/m (My) or normalized units
(my), depending on the setting of the <TT>normalize_aveM_output</TT>
option.
</LI>
<LI><B>Mz/mz:</B> magnetization component in the <B><I>z</I></B>
<!-- MATHEND
 
 -->
 direction,
averaged across the entire simulation, in A/m (Mz) or normalized units
(mz), depending on the setting of the <TT>normalize_aveM_output</TT>
option.
</LI>
<LI><B>Max Spin Ang:</B> maximum angle between neighboring spins
having non-zero magnetization <B><I>M</I><SUB>s</SUB></B>
<!-- MATHEND
 
 -->
, measured in degrees.  The definition
of ``neighbor'' depends on the mesh, but for <TT>Oxs_RectangularMesh</TT>
the neighborhood of a point consists of 6 points, those nearest
forward and backward along each of the 3 coordinate axis directions.
</LI>
<LI><B>Stage Max Spin Ang:</B> the largest value of ``Max Spin
Ang'' obtained across the current stage, in degrees.
</LI>
<LI><B>Run Max Spin Ang:</B> the largest value of ``Max Spin
Ang'' obtained across the current run, in degrees.
</LI>
<LI><B>Wall time:</B> Wall clock time, in seconds.
</LI>
</UL>
As is the case for the <TT>Oxs_TimeDriver</TT>, the three ``Max Spin Ang''
outputs and ``Wall time'' are disabled by default.  They angle outputs
are enabled by setting the <B>report_max_spin_angle</B> option to
to 1, and the wall time output is enabled by setting the
<B>report_wall_time</B> option to to 1.

<P>
The vector field outputs are

<UL>
<LI><B>Magnetization:</B> magnetization vector <!-- MATH
 $\textbf{M}$
 -->
<B><B>M</B></B>
<!-- MATHEND
 
 -->
, in A/m.
</LI>
<LI><B>Spin:</B> unit magnetization <!-- MATH
 $\textbf{m}$
 -->
<B><B>m</B></B>
<!-- MATHEND
 
 -->
.  This output ignores the
<TT>vector_field_output_format</TT> <I> precision</I> setting, instead
always exporting at full precision.
</LI>
</UL>

<P>
<B>Examples:</B> <TT><B>cgtest.mif</B></TT>, <TT><B>stdprob3.mif</B></TT>.

<P>
</DD>
</DL>

<P>

<H3><A NAME="SECTION00083600000000000000"></A><A NAME="sec:oxsFieldObjects"></A>
<BR>
Field Objects
</H3>
Field objects return values (either scalar or vector) as a function of
position.  These are frequently used as embedded objects inside Specify
blocks of other <TT>Oxs_Ext</TT> objects to initialize spatially varying
quantities, such as material parameters or initial magnetization spin
configurations.  Units on the returned values will be dependent upon the
context in which they are used.

<P>
Scalar field objects are documented first.  Vector field objects are
considered farther below.
<DL>
<DD><A NAME="USF"></A><A NAME="5795"></A></DD>
<DT><STRONG>Oxs_UniformScalarField:<A NAME="item:UniformScalarField"></A></STRONG></DT>
<DD>Returns the same constant value regardless of the import position.
   The Specify block takes one parameter, <B>value</B>, which is the
   returned constant value.  This class is frequently embedded inline to
   specify homogeneous material parameters.  For example, inside a driver
   Specify block we may have
<BLOCKQUOTE><PRE>
Specify Oxs_TimeDriver {
    ...
    Ms { Oxs_UniformScalarField {
       value 8e5
    }}
    ...
}
</PRE>
</BLOCKQUOTE>
As discussed in
the section on <A HREF="MIF_2.1.html#par:oxsExtReferencing">Oxs_Ext
referencing</A> in the <A HREF="MIF_2.1.html#sec:mif2format">MIF
2</A> documentation,

when embedding <TT>Oxs_UniformScalarField</TT>
or <A HREF="#item:UniformVectorField"><TT>Oxs_UniformVectorField</TT></A>
objects, a notational shorthand is allowed that lists only the value.
The previous example is exactly equivalent to
<BLOCKQUOTE><PRE>
Specify Oxs_TimeDriver {
    ...
    Ms 8e5
    ...
}
</PRE>
</BLOCKQUOTE>
where an implicit <TT>Oxs_UniformScalarField</TT> object is
created with <TT>value</TT> set to <TT>8e5</TT>.

<P>
<B>Examples:</B> <TT><B>sample.mif</B></TT>, <TT><B>cgtest.mif</B></TT>.

<P>
<A NAME="ASF"></A><A NAME="5821"></A></DD>
<DT><STRONG>Oxs_AtlasScalarField:<A NAME="item:AtlasScalarField"></A></STRONG></DT>
<DD>Declares values that are defined across individual regions of an
   <TT>Oxs_Atlas</TT>.  The Specify block looks like
      <BLOCKQUOTE><DL><DT>
      <TT>Specify Oxs_AtlasScalarField {</TT>
      <DD><TT> atlas </TT><I>atlas_spec</I>
      <DD><TT> multiplier </TT><I>mult</I>
      <DD><TT> default_value </TT><I>scalar_field_spec</I>
      <DD><TT> values {</TT><DL>
          <DD><I>region1_label</I><TT>&nbsp;</TT><I>scalar_field_spec1</I>
          <DD><I>region2_label</I><TT>&nbsp;</TT><I>scalar_field_spec2</I>
          <DD> ...
      </DL><TT>}</TT>
      <DT><TT>}</TT></DL></BLOCKQUOTE><P>

<P>
The specified <B>atlas</B> is used to map cell locations to
   regions; the value at the cell location of the scalar field from the
   corresponding <B>values</B> sub-block is assigned to that cell.
   The <B>default_value</B> entry is optional; if specified, and if
   a cell's region is not included in the <TT>values</TT> sub-block, then
   the <TT>default_value</TT> scalar field is used.  If <TT>default_value</TT>
   is not specified, then missing regions will raise an error.

<P>
The scalar field entries may specify any of the scalar field types
   described in this (Field Objects) section.  As usual, one may provide
   a single numeric value in any of the <TT>scalar_field_spec</TT>
   positions; this will be interpreted as requesting a uniform (spatially
   homogeneous) field with the indicated value.

<P>
If the optional <B>multiplier</B> value is provided, then each
   field value is scaled (multiplied) by the value <I> mult</I>.

<P>
The vector field analogue to this class is
   <A HREF="#item:AtlasVectorField"><TT>Oxs_AtlasVectorField</TT></A>,
   which is described below in the vector fields portion of this
   section.

<P>
<B>Examples:</B> <TT><B>diskarray.mif</B></TT>, <TT><B>ellipsoid.mif</B></TT>,
<TT><B>grill.mif</B></TT>, <TT><B>spinvalve.mif</B></TT>, <TT><B>tclshapes.mif</B></TT>.

<P>
<A NAME="LSF"></A><A NAME="5841"></A></DD>
<DT><STRONG>Oxs_LinearScalarField:</STRONG></DT>
<DD>Returns a value that varies linearly with position.  The Specify
   block has the form:
      <BLOCKQUOTE><DL><DT>
      <TT>Specify Oxs_LinearScalarField {</TT>
      <DD><TT> norm </TT><I>value</I>
      <DD><TT> vector {</TT>
         <I>v<sub>x</sub></I><TT>&nbsp;</TT>
         <I>v<sub>y</sub></I><TT>&nbsp;</TT>
         <I>v<sub>z</sub></I> <TT>}</TT>
      <DD><TT> offset </TT><I>off</I>
      <DT><TT>}</TT></DL></BLOCKQUOTE><P>
If optional value <B>norm</B> is specified, then the given
   <B>vector</B> is first scaled to the requested size.  The
   <B>offset</B> entry is optional, with default value 0. For any
   given point <B>(<I>x</I>, <I>y</I>, <I>z</I>)</B>
<!-- MATHEND
 
 -->
, the scalar value returned by this
   object will be <!-- MATH
 $xv_x+yv_y+zv_z + off$
 -->
<B><I>xv</I><SUB>x</SUB> + <I>yv</I><SUB>y</SUB> + <I>zv</I><SUB>z</SUB> + <I>off</I></B>
<!-- MATHEND
 
 -->
.

<P>
<B>Example:</B> <TT><B>spinvalve-af.mif</B></TT>.

<P>
<A NAME="RSF"></A><A NAME="5847"></A></DD>
<DT><STRONG>Oxs_RandomScalarField:</STRONG></DT>
<DD><A NAME="item:RandomScalarField"></A>Defines a scalar field that varies spatially in a random fashion.
The Specify block has the form:
      <BLOCKQUOTE><DL><DT>
      <TT>Specify Oxs_RandomScalarField {</TT>
      <DD><TT> range_min </TT><I>minvalue</I>
      <DD><TT> range_max </TT><I>maxvalue</I>
      <DD><TT> cache_grid </TT><I>mesh_spec</I>
      <DT><TT>}</TT></DL></BLOCKQUOTE><P>
The value at each position is drawn uniformly from the range declared by
the two required parameters, <B>range_min</B> and
<B>range_max</B>.  There is also an optional parameter,
<B>cache_grid</B>, which takes a mesh specification that describes
the grid used for spatial discretization.  If
<B>cache_grid</B> is not specified, then each call to
<TT>Oxs_RandomScalarField</TT> generates a different field.  If you want to
use the same random scalar field in two places (as a base for setting,
say anisotropy coefficients and saturation magnetization), then specify
<B>cache_grid</B> with the appropriate (usually the base problem)
mesh.

<P>
<B>Examples:</B> <TT><B>randomshape.mif</B></TT>, <TT><B>stdprob1.mif</B></TT>.

<P>
<A NAME="SSF"></A><A NAME="5858"></A></DD>
<DT><STRONG>Oxs_ScriptScalarField:<A NAME="item:ScriptScalarField"></A></STRONG></DT>
<DD>Analogous to the parallel
<A HREF="#item:ScriptVectorField"><TT>Oxs_ScriptVectorField</TT></A> 
class, this class produces a scalar field dependent on a Tcl script
and optionally other scalar and vector fields.  The Specify block has
the form
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_ScriptScalarField:</TT><I>name</I> <TT>{</TT>
<DD><TT>script </TT> <I>Tcl_script</I>
<DD><TT>script_args {</TT> <I>args_request</I> <TT>}</TT>
<DD><TT>scalar_fields {</TT> <I>scalar_field_spec</I><TT> ...}</TT>
<DD><TT>vector_fields {</TT> <I>vector_field_spec</I><TT> ...}</TT>
<DD><TT>atlas </TT> <I>atlas_spec</I>
<DD><TT>xrange {</TT> <I>xmin<TT>&nbsp;</TT>xmax</I> <TT>}</TT>
<DD><TT>yrange {</TT> <I>ymin<TT>&nbsp;</TT>ymax</I> <TT>}</TT>
<DD><TT>zrange {</TT> <I>zmin<TT>&nbsp;</TT>zmax</I> <TT>}</TT>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
For each point of interest, the specified <B>script</B> is
   called with the arguments requested by <B>script_args</B>
   appended to the command, as explained in the <A HREF="MIF_2.1.html#par:supportProcs">User
   Defined Support Procedures</A> section of the MIF&nbsp;2 file
   format documentation.  The value for <TT>script_args</TT> should be a
   subset of <TT> {rawpt relpt minpt maxpt span scalars vectors }</TT>.

<P>
If <TT>rawpt</TT> is requested, then when the Tcl proc is called, at
   the corresponding spot in the argument list the <TT>x</TT>, <TT>y</TT>,
   <TT>z</TT> values of point will be placed, in problem coordinates (in
   meters).  The points so passed will usually be node points in the
   simulation discretization (the <A HREF="#sec:Meshes">mesh</A>), but
   this does not have to be the case in general.  The <TT>relpt</TT>,
   <TT>minpt</TT>, <TT>maxpt</TT>, and <TT>span</TT> rely on a definition of a
   <I>bounding box</I>, which is an axes parallel parallelepiped.  The
   bounding box must be specified by either referencing an
   <B>atlas</B>, or by explicitly stating the range via the three
   entries <B>xrange</B>, <B>yrange</B>, <B>zrange</B> (in
   meters).  The <TT>minpt</TT> and <TT>maxpt</TT> arguments list the minimum
   and maximum values of the bounding box (coordinate by coordinate),
   while <TT>span</TT> provides the 3-vector resulting from <!-- MATH
 $(\texttt{maxpt} -
   \texttt{minpt})$
 -->
<B>(<texttt>maxpt</texttt> - <texttt>minpt</texttt>)</B>
<!-- MATHEND
 
 -->
.  The <TT>relpt</TT> selection provides <TT>x_rel</TT>,
   <TT>y_rel</TT>, <TT>z_rel</TT>, where each element lies in the range
   <B>[0, 1]</B>
<!-- MATHEND
 
 -->
, indicating a relative position between <TT>minpt</TT> and
   <TT>maxpt</TT>, coordinate-wise.

<P>
Each of the <TT>script_args</TT> discussed so far places exactly 3
   arguments onto the Tcl proc argument list.  The last two,
   <TT>scalars</TT> and <TT>vectors</TT>, place arguments depending on the size
   of the <B>scalar_fields</B> and <B>vector_fields</B> lists.
   The <TT>scalar_fields</TT> value is a list of other scalar field
   objects.  Each scalar field is evaluated at the point in question,
   and the resulting scalar value is placed on the Tcl proc argument
   list, in order.  The <TT>vector_fields</TT> option works similarly,
   except each vector field generates three points for the Tcl proc
   argument list, since the output from vector field objects is a three
   vector.  Although the use of these entries appears complicated, this
   is a quite powerful facility that allows nearly unlimited control for
   the modification and combination of other field objects.  Both
   <TT>scalar_fields</TT> and <TT>vector_fields</TT> entries are optional.

<P>
If <TT>script_args</TT> is not specified, the default value <TT>relpt</TT>
   is used.

<P>
Note that if <TT>script_args</TT> includes <TT>relpt</TT>, <TT>minpt</TT>,
   <TT>maxpt</TT>, or <TT>span</TT>, then a bounding box must be specified, as
   discussed above.  The following example uses the explicit range
   method.  See the <A HREF="#SVF"><TT>Oxs_ScriptVectorField</TT></A>
   documentation
   for an example using an atlas specification.
<BLOCKQUOTE><PRE>
proc Ellipsoid { xrel yrel zrel } {
    set xrad [expr {$xrel - 0.5}]
    set yrad [expr {$yrel - 0.5}]
    set zrad [expr {$zrel - 0.5}]
    set test [expr {$xrad*$xrad+$yrad*$yrad+$zrad*$zrad}]
    if {$test&gt;0.25} {return 0}
    return 8.6e5
}

Specify Oxs_ScriptScalarField {
    script Ellipsoid
    xrange { 0   1e-6 }
    yrange { 0 250e-9 }
    zrange { 0  50e-9 }
}
</PRE>
</BLOCKQUOTE>
   This <TT>Oxs_ScriptScalarField</TT> object returns 8.6e5 if the import (x,y,z) lies within the ellipsoid
   inscribed inside the axes parallel parallelepiped defined by (xmin=0,
   ymin=0, zmin=0) and (xmax=1e-6, ymax=250e-9, zmax=50e-9), and 0
   otherwise.
   See also the discussion of the
   <A HREF="MIF_2.1.html#html:ReadFile"><TT>ReadFile</TT></A> MIF extension command
    for an example using
   an imported image file for similar purposes.

<P>
Below is one more example, illustrating the use of the
   <TT>vector_fields</TT> option.
<BLOCKQUOTE><PRE>
proc DotProduct { x1 y1 z1 x2 y2 z2 } {
    return [expr {$x1*$x2+$y1*$y2+$z1*$z2}]
}

Specify Oxs_FileVectorField:file1 {
    atlas :atlas
    file  file1.omf
}

Specify Oxs_UniformVectorField:dir111 {
    norm 1
    vector {1 1 1}
}

Specify Oxs_ScriptScalarField:project {
    script DotProduct
    script_args vectors
    vector_fields {:file1 :dir111}
}
</PRE>
</BLOCKQUOTE>
The scalar field <TT>:project</TT> yields at each point in space the
projection of the vector field <TT>:file1</TT> onto the [1,1,1] direction.

<P>
<B>Examples:</B> <TT><B>antidots-filled.mif</B></TT>,
<TT><B>ellipsoid-fieldproc.mif</B></TT>, <TT><B>manyregions-scriptfields.mif</B></TT>,
<TT><B>manyspheres.mif</B></TT>, <TT><B>varalpha.mif</B></TT>.

<P>
<A NAME="VMSF"></A><A NAME="5939"></A></DD>
<DT><STRONG>Oxs_VecMagScalarField:</STRONG></DT>
<DD>The <TT>Oxs_VecMagScalarField</TT> class produces a scalar field
from a vector field by taking the norm of the vector field on a
point-by-point basis, i.e.,
<P><!-- MATH
 \begin{displaymath}
\|\mbox{\boldmath$v$}\| = \sqrt{v_x^2+v_y^2+v_z^2}.
\end{displaymath}
 -->
</P>
<DIV ALIGN="CENTER">
<BIG><B>|<IMG
 WIDTH="17" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img60.gif"
 ALT="$\displaystyle \mbox{\boldmath$v$}$">| = <IMG
 WIDTH="125" HEIGHT="50" ALIGN="MIDDLE" BORDER="0"
 SRC="img61.gif"
 ALT="$\displaystyle \sqrt{{v_x^2+v_y^2+v_z^2}}$">.</B></BIG>
</DIV><P>
<!-- MATHEND
 
 -->
</P>
The Specify block has the form:
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_VecMagScalarField {</TT>
<DD><TT> field </TT><I>vector_field_spec</I>
<DD><TT> multiplier </TT><I>mult</I>
<DD><TT> offset </TT><I>off</I>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
The <B>multiplier</B> and <B>offset</B> entries are applied
after the vector norm, i.e., the resulting scalar field is
<!-- MATH
 $\texttt{mult}\ast\|\mbox{\boldmath $v$}\|+\texttt{off}$
 -->
<B><texttt>mult</texttt> <TT>*</TT> |<B><I>v</I></B>
<!-- MATHEND
 
 -->
| + <texttt>off</texttt></B>
<!-- MATHEND
 
 -->
.  The default values
for <TT>mult</TT> and <TT>off</TT> are 1 and 0, respectively.

<P>
The functionality of the <TT>Oxs_VecMagScalarField</TT> class may be achieved
with the <TT>Oxs_ScriptScalarField</TT> class by using the
<TT>vector_fields</TT> option and a Tcl script to compute the vector
norm.  However, this particular functionality is needed frequently
enough that a specialized class is useful.  For example, this class can
be used in conjunction with a vector field object to set
both the saturation magnetization distribution (<B><I>M</I><SUB>s</SUB></B>
<!-- MATHEND
 
 -->
) and the initial
magnetization:
<BLOCKQUOTE><PRE>
Specify Oxs_FileVectorField:file1 {
    atlas :atlas
    file  file1.omf
}

Specify Oxs_TimeDriver {
    basename test
    evolver :evolve
    stopping_dm_dt 0.01
    mesh :mesh
    m0 :file1
    Ms { Oxs_VecMagScalarField {
       field :file1
    }}
}
</PRE>
</BLOCKQUOTE>

<P>
<B>Example:</B> <TT><B>sample-vecrotate.mif</B></TT>.

<P>
<A NAME="SOSF"></A><A NAME="5961"></A></DD>
<DT><STRONG>Oxs_ScriptOrientScalarField:<A NAME="item:ScriptOrientScalarField"></A></STRONG></DT>
<DD>Scalar fields provide scalar values as a function of position across
three-space.  The <TT>Oxs_ScriptOrientScalarField</TT> class is used to
compose a transformation on the input position before evaluation by
a scalar field.  The Specify block has the form:
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_ScriptOrientScalarField:</TT><I>name</I> <TT>{</TT>
<DD><TT>field </TT> <I>scalar_field_spec</I>
<DD><TT>script </TT> <I>Tcl_script</I>
<DD><TT>script_args {</TT> <I>args_request</I> <TT>}</TT>
<DD><TT>atlas </TT> <I>atlas_spec</I>
<DD><TT>xrange {</TT> <I>xmin</I><TT>&nbsp;</TT><I>xmax</I> <TT>}</TT>
<DD><TT>yrange {</TT> <I>ymin</I><TT>&nbsp;</TT><I>ymax</I> <TT>}</TT>
<DD><TT>zrange {</TT> <I>zmin</I><TT>&nbsp;</TT><I>zmax</I> <TT>}</TT>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
The <B>field</B> argument should refer to a scalar field object.
The <B>script</B> is a Tcl script that should return a position
vector that will be sent on the <TT>field</TT> object to ultimately
produce a scalar value.  The arguments to the <TT>Tcl_script</TT> are
determined by <B>script_args</B>, which should be a subset of
<TT> {relpt rawpt minpt maxpt span }</TT>.  If any arguments other than
<TT>rawpt</TT> are requested, then the bounding box must be specified by
either the <B>atlas</B> option, or else through the three <B>xrange</B>,
<B>yrange</B>, <B>zrange</B> entries.  The default value for
<TT>script_args</TT> is <TT>relpt</TT>.

<P>
The <TT>Oxs_ScriptOrientScalarField</TT> class can be used to change the
``orientation'' of a scalar field, as in the following simple example,
which reflects the <TT>:file1mag</TT> scalar field across the yz-plane:
<BLOCKQUOTE><PRE>
Specify Oxs_FileVectorField:file1 {
    atlas :atlas
    file  file1.omf
}

Specify Oxs_VecMagScalarField:file1mag {
   field :file1
}

proc Reflect { x y z xmin ymin zmin xmax ymax zmax} {
   return [list [expr {($xmax+$xmin-$x)}] $y $z]
}

Specify Oxs_ScriptOrientScalarField:reflect {
   field :file1mag
   script Reflect
   script_args {rawpt minpt maxpt}
   atlas :atlas
}
</PRE>
</BLOCKQUOTE>
See also the
<A HREF="#item:ScriptOrientVectorField"><TT>Oxs_ScriptOrientVectorField</TT></A>
class for
analogous operations on vector fields.

<P>
<B>Example:</B> <TT><B>sample-reflect.mif</B></TT>.

<P>
<A NAME="AOSF"></A><A NAME="5988"></A></DD>
<DT><STRONG>Oxs_AffineOrientScalarField:<A NAME="item:AffineOrientScalarField"></A></STRONG></DT>
<DD>The <TT>Oxs_AffineOrientScalarField</TT> class is similar to the
<TT>Oxs_ScriptOrientScalarField</TT> class, except that the transformation
on the import position is by an affine transformation defined in terms
of a 3x3 matrix and an offset instead of a
Tcl script.  Although this functionality can be obtained by an
appropriate Tcl script, the <TT>Oxs_AffineOrientScalarField</TT> is
easier to use and will run faster, as the underlying transformation is
performed by compiled C++ instead of Tcl script.

<P>
The Specify block has the form:
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_AffineOrientScalarField {</TT>
<DD><TT> field </TT><I>scalar_field_spec</I>
<DD><TT> M
  {</TT> <I>matrix_entries</I><TT>&nbsp;</TT><I>...</I> <TT>}</TT>
<DD><TT> offset {</TT>
   <I>off<sub>x</sub></I><TT>&nbsp;</TT>
   <I>off<sub>y</sub></I><TT>&nbsp;</TT>
   <I>off<sub>z</sub></I> <TT>}</TT>
<DD><TT> inverse </TT><I>invert_flag</I>
<DD><TT> inverse_slack </TT><I>slack</I>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
If <!-- MATH
 $F(\mbox{\boldmath $x$})$
 -->
<B><I>F</I>(<B><I>x</I></B>
<!-- MATHEND
 
 -->
)</B>
<!-- MATHEND
 
 -->
 represents the scalar field specified by the
<B>field</B> value, then the resulting transformed scalar field is
<!-- MATH
 $F(M\mbox{\boldmath $x$}+\textbf{off})$
 -->
<B><I>F</I>(<I>M</I><B><I>x</I></B>
<!-- MATHEND
 
 -->
 + <B>off</B>)</B>
<!-- MATHEND
 
 -->
.  Here <B>M</B> is a
3x3 matrix, which may be specified by a list
of 1, 3, 6 or 9 entries.  If the <TT>matrix_entries</TT> list consists of a
single value, then <B><I>M</I></B>
<!-- MATHEND
 
 -->
 is taken to be that value times the identity
matrix, i.e., <B><I>M</I></B>
<!-- MATHEND
 
 -->
 is a homogeneous scaling transformation.  If
<TT>matrix_entries</TT> consists of 3 values, then <B><I>M</I></B>
<!-- MATHEND
 
 -->
 is taken to be the
diagonal matrix with those three values along the diagonal.
If <TT>matrix_entries</TT> is 6 elements long, then <B><I>M</I></B>
<!-- MATHEND
 
 -->
 is assumed to be a
symmetric matrix, where the 6 elements specified correspond to <B><I>M</I><SUB>11</SUB></B>
<!-- MATHEND
 
 -->
,
<B><I>M</I><SUB>12</SUB></B>
<!-- MATHEND
 
 -->
, <B><I>M</I><SUB>13</SUB></B>
<!-- MATHEND
 
 -->
, <B><I>M</I><SUB>22</SUB></B>
<!-- MATHEND
 
 -->
, <B><I>M</I><SUB>23</SUB></B>
<!-- MATHEND
 
 -->
, and <B><I>M</I><SUB>33</SUB></B>
<!-- MATHEND
 
 -->
.  Finally, if
<TT>matrix_entries</TT> is 9 elements long, then the elements specify the
entire matrix, in the order <B><I>M</I><SUB>11</SUB></B>
<!-- MATHEND
 
 -->
, <B><I>M</I><SUB>12</SUB></B>
<!-- MATHEND
 
 -->
, <B><I>M</I><SUB>13</SUB></B>
<!-- MATHEND
 
 -->
, <B><I>M</I><SUB>21</SUB></B>
<!-- MATHEND
 
 -->
,
..., <B><I>M</I><SUB>33</SUB></B>
<!-- MATHEND
 
 -->
.  If <B><I>M</I></B>
<!-- MATHEND
 
 -->
 is not specified, then it is taken to be
the identity matrix.

<P>
The <B>offset</B> entry is simply a 3-vector that is added to
<!-- MATH
 $M\mbox{\boldmath $x$}$
 -->
<B><I>M</I><B><I>x</I></B>
<!-- MATHEND
 
 -->
</B>
<!-- MATHEND
 
 -->
.  If <TT>offset</TT> is not specified, then
it is set to the zero vector.

<P>
It is frequently the case that the transformation that one wants to
apply is not <!-- MATH
 $M\mbox{\boldmath $x$}+\textbf{off}$
 -->
<B><I>M</I><B><I>x</I></B>
<!-- MATHEND
 
 -->
 + <B>off</B></B>
<!-- MATHEND
 
 -->
, but rather the
inverse, i.e., <!-- MATH
 $M^{-1}(\mbox{\boldmath $x$}-\textbf{off})$
 -->
<B><I>M</I><SUP>-1</SUP>(<B><I>x</I></B>
<!-- MATHEND
 
 -->
 - <B>off</B>)</B>
<!-- MATHEND
 
 -->
.  Provided <B><I>M</I></B>
<!-- MATHEND
 
 -->
is nonsingular, this can be accomplished by setting the
<B>inverse</B> option to 1.  In this case the matrix <B><I>M</I>.<I>M</I><SUP>-1</SUP></B>
<!-- MATHEND
 
 -->
 is
compared to the identity matrix, to check the accuracy of the matrix
inversion.  If any entry in <B><I>M</I>.<I>M</I><SUP>-1</SUP></B>
<!-- MATHEND
 
 -->
 differs from <B><I>I</I></B>
<!-- MATHEND
 
 -->
 by more than the
8-byte float machine precision (typically
2e-16) times the value of
<B>inverse_slack</B>, then an error is raised. The default setting
for <TT>invert_flag</TT> is 0, meaning don't invert,
and the default setting for <TT>slack</TT> is 128.

<P>
Here is an example using <TT>Oxs_AffineOrientScalarField</TT> to rotate a
field by 90 degrees counterclockwise about the
<B><I>z</I></B>
<!-- MATHEND
 
 -->
-axis.  Note that the specified atlas is square in <B><I>x</I></B>
<!-- MATHEND
 
 -->
 and <B><I>y</I></B>
<!-- MATHEND
 
 -->
, with
the origin of the atlas coordinates in the center of the atlas volume.
<BLOCKQUOTE><PRE>
Specify Oxs_BoxAtlas:atlas {
  xrange {-250e-9 250e-9}
  yrange {-250e-9 250e-9}
  zrange { -15e-9  15e-9}
}

Specify Oxs_FileVectorField:file1 {
    atlas :atlas
    file  file1.omf
}

Specify Oxs_VecMagScalarField:file1mag {
   field :file1
}

Specify Oxs_AffineOrientScalarField:reflect {
   field :file1mag
   M { 0 1 0
      -1 0 0
       0 0 1 }
}
</PRE>
</BLOCKQUOTE>

<P>
See also the
<A HREF="#item:AffineOrientVectorField"><TT>Oxs_AffineOrientVectorField</TT></A>
class for
analogous operations on vector fields.

<P>
<B>Example:</B> <TT><B>sample-rotate.mif</B></TT>.

<P>
<A NAME="ATSF"></A><A NAME="6045"></A></DD>
<DT><STRONG>Oxs_AffineTransformScalarField:<A NAME="item:AffineTransformScalarField"></A></STRONG></DT>
<DD>Like the <TT>Oxs_AffineOrientScalarField</TT> class, this class composes
an affine transform with a separate scalar field, but in this case the
affine transform is applied <I>after</I> the field evaluation.
The Specify block has the form:
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_AffineTransformScalarField {</TT>
<DD><TT> field </TT><I>scalar_field_spec</I>
<DD><TT> multiplier </TT><I>mult</I>
<DD><TT> offset </TT><I>off</I>
<DD><TT> inverse </TT><I>invert_flag</I>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
If <!-- MATH
 $F(\mbox{\boldmath $x$})$
 -->
<B><I>F</I>(<B><I>x</I></B>
<!-- MATHEND
 
 -->
)</B>
<!-- MATHEND
 
 -->
 represents the scalar field specified by the
<B>field</B> value, then the resulting scalar field is
<!-- MATH
 $\textrm{mult}*F(\mbox{\boldmath $x$})+\textrm{off}$
 -->
<B>mult*<I>F</I>(<B><I>x</I></B>
<!-- MATHEND
 
 -->
) + off</B>
<!-- MATHEND
 
 -->
.  Since the output
from <B><I>F</I></B>
<!-- MATHEND
 
 -->
 is a scalar, both <B>multiplier</B> and <B>offset</B>
are scalars.  If <B>inverse</B> is 1, then the transform is changed
to <!-- MATH
 $\left(F(\mbox{\boldmath $x$})-\textrm{off}\right)/\textrm{mult}$
 -->
<B><IMG
 WIDTH="12" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img62.gif"
 ALT="$ \left(\vphantom{F(\mbox{\boldmath $x$})-\textrm{off}}\right.$"><I>F</I>(<B><I>x</I></B>
<!-- MATHEND
 
 -->
) - off<IMG
 WIDTH="12" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img63.gif"
 ALT="$ \left.\vphantom{F(\mbox{\boldmath $x$})-\textrm{off}}\right)$">/mult</B>
<!-- MATHEND
 
 -->
,
provided <TT>mult</TT> is non-zero.

<P>
The default values for <I> mult</I>, <I> off</I>, and
<I> invert_flag</I> are 1, 0, and 0, respectively.  The <TT>field</TT>
value is the only required entry.

<P>
The functionality provided by <TT>Oxs_AffineTransformScalarField</TT> can
also be produced by the
<A HREF="#item:ScriptScalarField"><TT>Oxs_ScriptScalarField</TT></A>
class with the
<TT>scalar_fields</TT> entry, but the <TT>Oxs_AffineTransformScalarField</TT>
class is faster and has a simpler interface.  See also the
<A HREF="#item:AffineTransformVectorField"><TT>Oxs_AffineTransformVectorField</TT></A>
class for analogous
operations on vector fields.

<P>
<B>Example:</B> <TT><B>sample-rotate.mif</B></TT>.

<P>
<A NAME="ISF"></A><A NAME="6076"></A></DD>
<DT><STRONG>Oxs_ImageScalarField:<A NAME="item:ImageScalarField"></A></STRONG></DT>
<DD>This class creates a scalar field using an image.  The Specify block has
the form
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_ImageScalarField:</TT><I>name</I> <TT>{</TT>
<DD><TT>image </TT> <I>pic</I>
<DD><TT>invert </TT> <I>invert_flag</I>
<DD><TT>multiplier </TT><I>mult</I>
<DD><TT>offset </TT><I>off</I>
<DD><TT>viewplane </TT> <I>view</I>
<DD><TT>atlas </TT> <I>atlas_spec</I>
<DD><TT>xrange {</TT> <I>xmin</I><TT>&nbsp;</TT><I>xmax</I> <TT>}</TT>
<DD><TT>yrange {</TT> <I>ymin</I><TT>&nbsp;</TT><I>ymax</I> <TT>}</TT>
<DD><TT>zrange {</TT> <I>zmin</I><TT>&nbsp;</TT><I>zmax</I> <TT>}</TT>
<DD><TT>exterior </TT><I>ext_flag</I>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
The <B>image</B> is interpreted as a monochromatic map, yielding a
scalar field with black corresponding to zero and white to one if
<B>invert</B> is 0 (the default), or with black corresponding to 1
and white to 0 if <TT>invert</TT> is 1.  Color images are converted to
grayscale by simply summing the red, green, and blue components.  A
<B>multiplier</B> option is available to change the range of values
from <B>[0, 1]</B>
<!-- MATHEND
 
 -->
 to <!-- MATH
 $[0,\mbox{\texttt{mult}}]$
 -->
<B>[0,<TT>mult</TT>]</B>
<!-- MATHEND
 
 -->
, after which the
<B>offset</B> value, if any, is added.

<P>
The <B>viewplane</B> is treated in the same manner as the viewplane
option in the <A HREF="#IA"><TT>Oxs_ImageAtlas</TT></A> class, and should
likewise take one of the three two-letter codes <TT>xy</TT> (default),
<TT>zx</TT> or <TT>yz</TT>.  The spatial scale is adjusted to fit the volume
specified by either the <B>atlas</B> or
<B>xrange/yrange/zrange</B> selections.  If the specified volume
does not fill the entire simulation volume, then points outside the
specified volume are handled as determined by the <B>exterior</B>
setting, which should be either a floating point value, or one of the
keywords <TT>boundary</TT> or <TT>error</TT>.  In the first case, the floating
point value is treated as a default value for points outside the image,
and should have a value in the range <B>[0, 1]</B>
<!-- MATHEND
 
 -->
.  The multiplier and offset
adjustments are made to this value in the same way as to points inside
the image.  If <I> ext_flag</I> is <TT>boundary</TT>, then points outside the
image are filled with the value of the closest point on the boundary of
the image.  If <I> ext</I> is <TT>error</TT> (the default), then an error
is raised if a value is needed for any point outside the image.

<P>
<B>Examples:</B> <TT><B>rotatecenterstage.mif</B></TT>, <TT><B>sample-reflect.mif</B></TT>.

<P>
</DD>
</DL>

<P>
The available vector field objects are:
<DL>
<DD><A NAME="UVF"></A><A NAME="6104"></A></DD>
<DT><STRONG>Oxs_UniformVectorField:<A NAME="item:UniformVectorField"></A></STRONG></DT>
<DD>Returns the same constant value regardless of the import position.
   The Specify block takes one required parameter, <B>vector</B>,
   which is a 3-element list of the vector to return, and one optional
   parameter, <B>norm</B>, which if specified adjusts the size of
   export vector to the specified magnitude.  For example,
   <BLOCKQUOTE><DL><DT>
      <TT>Specify Oxs_UniformVectorField {</TT>
      <DD><TT> norm 1</TT>
      <DD><TT> vector {1 1 1}</TT>
   <DT><TT>}</TT></DL></BLOCKQUOTE><P>
This object returns the unit vector <B>(<I>a</I>, <I>a</I>, <I>a</I>)</B>
<!-- MATHEND
 
 -->
, where
   a=1/sqrt(3), regardless of the import
   position.

<P>
This class is frequently embedded inline to specify spatially uniform
   quantities.  For example, inside a driver Specify block we may have

<P>
<BLOCKQUOTE><PRE>
Specify Oxs_TimeDriver {
    ...
    m0 { Oxs_UniformVectorField {
       vector {1 0 0}
    }}
    ...
}
</PRE>
</BLOCKQUOTE>
As discussed in
the section on <A HREF="MIF_2.1.html#par:oxsExtReferencing">Oxs_Ext
referencing</A> in the <A HREF="MIF_2.1.html#sec:mif2format">MIF
2</A> documentation,

when embedding <TT>Oxs_UniformVectorField</TT>
or <A HREF="#item:UniformScalarField"><TT>Oxs_UniformScalarField</TT></A>
objects, a notational shorthand is allowed that lists only the required
value.  The previous example is exactly equivalent to
<BLOCKQUOTE><PRE>
Specify Oxs_TimeDriver {
    ...
    m0 {1 0 0}
    ...
}
</PRE>
</BLOCKQUOTE>
where an implicit <TT>Oxs_UniformVectorField</TT> object is
created with the value of <TT>vector</TT> set to <TT> {1 0 0 }</TT>.

<P>
<B>Examples:</B> <TT><B>sample.mif</B></TT>, <TT><B>cgtest.mif</B></TT>.

<P>
<A NAME="AVF"></A><A NAME="6133"></A></DD>
<DT><STRONG>Oxs_AtlasVectorField:<A NAME="item:AtlasVectorField"></A></STRONG></DT>
<DD>Declares vector values that are defined across individual regions of
   an <TT>Oxs_Atlas</TT>.  The Specify block has the form
      <BLOCKQUOTE><DL><DT>
      <TT>Specify Oxs_AtlasVectorField {</TT>
      <DD><TT> atlas </TT><I>atlas_spec</I>
      <DD><TT> norm </TT><I>magval</I>
      <DD><TT> multiplier </TT><I>mult</I>
      <DD><TT> default_value </TT><I>vector_field_spec</I>
      <DD><TT> values {</TT><DL>
          <DD><I>region1_label</I><TT>&nbsp;</TT><I>vector_field_spec1</I>
          <DD><I>region2_label</I><TT>&nbsp;</TT><I>vector_field_spec2</I>
          <DD> ...
      </DL><TT>}</TT>
      <DT><TT>}</TT></DL></BLOCKQUOTE><P>
Interpretation is analogous to the
   <A HREF="#item:AtlasScalarField"><TT>Oxs_AtlasScalarField</TT></A>
   specify block, except here the output values are 3 dimensional
   vectors rather than scalars.  Thus the values associated with each
   region are vector fields rather than scalar fields.  Any of the
   vector field types described in this (Field Objects) section may be
   used.  As usual, one may provided a braced list of three numeric
   values to request a uniform (spatially homogeneous) vector field with
   the indicated value.

<P>
The optional <B>norm</B> parameter causes each vector value to be
   scaled to have magnitude <I> magval</I>.  The optional
   <B>multiplier</B> value scales the field values.  If both
   <TT>norm</TT> and <TT>multiplier</TT> are specified, then the field vectors
   are first normalized before being scaled by the multiplier value.

<P>
<B>Examples:</B> <TT><B>diskarray.mif</B></TT>, <TT><B>exchspring.mif</B></TT>,
<TT><B>imageatlas.mif</B></TT>, <TT><B>spinvalve.mif</B></TT>.

<P>
<A NAME="SVF"></A><A NAME="6148"></A></DD>
<DT><STRONG>Oxs_ScriptVectorField:<A NAME="item:ScriptVectorField"></A></STRONG></DT>
<DD>Conceptually similar to the
<A HREF="#item:ScriptScalarField"><TT>Oxs_ScriptScalarField</TT></A> scalar
field object,
except that the script should return a vector (as a 3 element list)
rather than a scalar.  In addition to the parameters accepted by
<TT>Oxs_ScriptScalarField</TT>, <TT>Oxs_ScriptVectorField</TT> also accepts
an optional parameter <B>norm</B>.  If specified, the return
values from the script are size adjusted to the specified magnitude.
If both <TT>norm</TT> and <TT>multiplier</TT> are specified, then
the field vectors are first normalized before being scaled by the
multiplier value.

<P>
The following example produces a vortex-like unit vector field, with
an interior core region pointing parallel to the <B><I>z</I></B>
<!-- MATHEND
 
 -->
-axis.  Here the
scaling region is specified using an <TT>atlas</TT> reference to an
object named ``:atlas'', which is presumed to be defined earlier in
the MIF file.  See the <TT>Oxs_ScriptScalarField</TT> sample Specify
block for an example using the explicit range option.
<BLOCKQUOTE>
<PRE>
proc Vortex { xrel yrel zrel } {
    set xrad [expr {$xrel-0.5}]
    set yrad [expr {$yrel-0.5}]
    set normsq [expr {$xrad*$xrad+$yrad*$yrad}]
    if {$normsq &lt;= 0.025} {return "0 0 1"}
    return [list [expr {-1*$yrad}] $xrad 0]
}

Specify Oxs_ScriptVectorField {
    script Vortex
    norm  1
    atlas :atlas
}
</PRE>
</BLOCKQUOTE>
See also the
<A HREF="#item:MaskVectorField"><TT>Oxs_MaskVectorField</TT></A>
documentation and the discussion of the
<A HREF="MIF_2.1.html#html:ReadFile"><TT>ReadFile</TT></A> MIF extension command

<P>
for other example uses of the <TT>Oxs_ScriptVectorField</TT> class.

<P>
<B>Examples:</B> <TT><B>cgtest.mif</B></TT>, <TT><B>ellipsoid.mif</B></TT>,
<TT><B>manyregions-scriptfields.mif</B></TT>, <TT><B>sample-vecreflect.mif</B></TT>,
<TT><B>stdprob3.mif</B></TT>, <TT><B>yoyo.mif</B></TT>.

<P>
<A NAME="FVF"></A><A NAME="6175"></A></DD>
<DT><STRONG>Oxs_FileVectorField:<A NAME="item:FileVectorField"></A></STRONG></DT>
<DD>Provides a file-specified vector field.  The Specify block has the form
      <BLOCKQUOTE><DL><DT>
      <TT>Specify Oxs_FileVectorField {</TT>
      <DD><TT>file </TT><I>filename</I>

      <DD><TT>atlas </TT> <I>atlas_spec</I>
      <DD><TT>xrange {</TT> <I>xmin</I><TT>&nbsp;</TT><I>xmax</I> <TT>}</TT>
      <DD><TT>yrange {</TT> <I>ymin</I><TT>&nbsp;</TT><I>ymax</I> <TT>}</TT>
      <DD><TT>zrange {</TT> <I>zmin</I><TT>&nbsp;</TT><I>zmax</I> <TT>}</TT>
      <DD><TT>spatial_scaling {</TT>
        <I>xscale</I><TT>&nbsp;</TT><I>yscale</I><TT>&nbsp;</TT><I>zscale</I>
      <TT>}</TT>
      <DD><TT>spatial_offset {</TT>
        <I>xoff</I><TT>&nbsp;</TT><I>yoff</I><TT>&nbsp;</TT><I>zoff</I>
      <TT>}</TT>
      <DD><TT>exterior </TT><I>ext_flag</I>
      <DD><TT>norm </TT><I>magnitude</I>
      <DD><TT>multiplier </TT><I>mult</I>
      <DT><TT>}</TT></DL></BLOCKQUOTE><P>
Required values in the Specify block are the name of the input vector
   field file and the desired scaling parameters.  The filename is
   specified via the <B>file</B> entry, which names a file
   containing a vector field in one of the formats recognized by
   <A HREF="Vector_Field_File_Format_Co.html#sec:avf2ovf"
 NAME="6182"><B>avf2ovf</B></A>.  If
   <B>atlas</B> or <B>xrange/yrange/zrange</B> are specified,
   then the file will be scaled and translated as necessary to fit that
   scaling region, in the same manner as done, for example, by
   the <A HREF="#SSF"><TT>Oxs_ScriptScalarField</TT></A> and
   <A HREF="#SVF"><TT>Oxs_ScriptVectorField</TT></A> classes.
   Alternatively, one may specify <B>spatial_scaling</B> and
   <B>spatial_offset</B> directly.  In this case the vector spatial
   positions are taken as specified in the file, multiplied
   component-wise by <TT>(xscale,yscale,zscale)</TT>, and then translated by
   <TT>(xoff,yoff,zoff)</TT>.  If you want to use the spatial coordinates as
   directly specified in the file, use <TT>(1,1,1)</TT> for spatial_scaling
   and <TT>(0,0,0)</TT> for spatial_offset.

<P>
In all cases, once the input field has been scaled and translated, it
   is then sub-sampled (zeroth-order fit) as necessary to match the
   simulation mesh.

<P>
The <B>exterior</B> flag determines the behavior at ``exterior
   points'', i.e., locations (if any) in the simulation mesh that lie
   outside the extent of the scaled and translated vector field.  The
   <I> ext_flag</I> should be either a three-vector, or one of the
   keywords <TT>boundary</TT> or <TT>error</TT>.  If a three-vector is given,
   then that value is supplied at all exterior points.  If
   <I> ext_flag</I> is set to <TT>boundary</TT>, then the value used is
   the point on the boundary of the input vector field that is closest
   to the exterior point.  The default setting for <I> ext_flag</I> is
   <TT>error</TT>, which raises an error if there are any exterior points.

<P>
The magnitude of the field can be modified by the optional
   <B>norm</B> and <B>multiplier</B> attributes.  If the norm
   parameter is given, then each vector in the field will be
   renormalized to the specified magnitude.  If the multiplier parameter
   is given, then each vector in the field will be multiplied by the
   given scalar value.  If the multiplier value is negative, the field
   direction will be reversed.  If both <TT>norm</TT> and <TT>multiplier</TT>
   are given, then the field vectors are renormalized before being
   scaled by the multiplier value.

<P>
<B>Examples:</B> <TT><B>stdprob3.mif</B></TT>, <TT><B>yoyo.mif</B></TT>.

<P>
<A NAME="RVF"></A><A NAME="6210"></A></DD>
<DT><STRONG>Oxs_RandomVectorField:</STRONG></DT>
<DD>Similar to
<A HREF="#item:RandomScalarField"><TT>Oxs_RandomScalarField</TT></A>, but defines a vector field rather than a scalar field that
varies spatially in a random fashion.  The Specify block has the form:
      <BLOCKQUOTE><DL><DT>
      <TT>Specify Oxs_RandomVectorField {</TT>
      <DD><TT> min_norm </TT><I>minvalue</I>
      <DD><TT> max_norm </TT><I>maxvalue</I>
      <DD><TT> cache_grid </TT><I>mesh_spec</I>
      <DT><TT>}</TT></DL></BLOCKQUOTE><P>
The Specify block takes two required parameters, <B>min_norm</B>
and <B>max_norm</B>.  The vectors produced will have magnitude
between these two specified values.  If <TT>min_norm</TT> = <TT>max_norm</TT>,
then the samples are uniformly distributed on the sphere of that radius.
Otherwise, the samples are uniformly distributed in the hollow spherical
volume with inner radius <TT>min_norm</TT> and outer radius <TT>max_norm</TT>.
There is also an optional parameter, <B>cache_grid</B>, which takes
a mesh specification that describes the grid used for cache spatial
discretization.  If <B>cache_grid</B> is not specified, then each
call to <TT>Oxs_RandomVectorField</TT> generates a different field.  If you
want to use the same random vector field in two places (as a base for
setting, say anisotropy axes and initial magnetization), then specify
<B>cache_grid</B> with the appropriate (usually the base problem)
mesh.

<P>
<B>Examples:</B> <TT><B>diskarray.mif</B></TT>, <TT><B>sample2.mif</B></TT>,
<TT><B>randomshape.mif</B></TT> <TT><B>stdprob1.mif</B></TT>.

<P>
<A NAME="PRVF"></A><A NAME="6229"></A></DD>
<DT><STRONG>Oxs_PlaneRandomVectorField:</STRONG></DT>
<DD>Similar to <TT>Oxs_RandomVectorField</TT>, except that samples are
   drawn from 2D planes rather than 3-space.  The Specify block has the
   form
      <BLOCKQUOTE><DL><DT>
      <TT>Specify Oxs_RandomVectorField {</TT>
      <DD><TT> plane_normal </TT><I>vector_field_spec</I>
      <DD><TT> min_norm </TT><I>minvalue</I>
      <DD><TT> max_norm </TT><I>maxvalue</I>
      <DD><TT> cache_grid </TT><I>mesh_spec</I>
      <DT><TT>}</TT></DL></BLOCKQUOTE><P>
The <B>min_norm</B>, <B>max_norm</B>, and
  <B>cache_grid</B> parameters have the same meaning as for the
  <TT>Oxs_RandomVectorField</TT> class.  The additional parameter,
  <B>plane_normal</B>, specifies a vector field that at each point
  provides a vector that is orthogonal to the plane from which the
  random vector at that point is to be drawn.  If the vector field is
  specified explicitly as three real values, then a spatially uniform
  vector field is produced and all the random vectors will lie in the
  same plane.  More generally, however, the normal vectors (and
  associated planes) may vary from point to point.  As a special case,
  if a normal vector at a point is the zero vector, then no planar
  restriction is made and the resulting random vector is drawn uniformly
  from a hollow ball in three space satisfying the minimum/maximum norm
  constraints.

<P>
<B>Example:</B> <TT><B>sample2.mif</B></TT>.

<P>
<A NAME="SOVF"></A><A NAME="6238"></A></DD>
<DT><STRONG>Oxs_ScriptOrientVectorField:<A NAME="item:ScriptOrientVectorField"></A></STRONG></DT>
<DD>This class is analogous to the
<A HREF="#item:ScriptOrientScalarField"><TT>Oxs_ScriptOrientScalarField</TT></A>
class.
The Specify block has the form:
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_ScriptOrientVectorField:</TT><I>name</I> <TT>{</TT>
<DD><TT>field </TT> <I>vector_field_spec</I>
<DD><TT>script </TT> <I>Tcl_script</I>
<DD><TT>script_args {</TT> <I>args_request</I> <TT>}</TT>
<DD><TT>atlas </TT> <I>atlas_spec</I>
<DD><TT>xrange {</TT> <I>xmin</I><TT>&nbsp;</TT><I>xmax</I> <TT>}</TT>
<DD><TT>yrange {</TT> <I>ymin</I><TT>&nbsp;</TT><I>ymax</I> <TT>}</TT>
<DD><TT>zrange {</TT> <I>zmin</I><TT>&nbsp;</TT><I>zmax</I> <TT>}</TT>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
The interpretation of the specify block and the operation of the Tcl script is exactly the same as for the <TT>Oxs_ScriptOrientScalarField</TT>
class, except the input <B>field</B> and the resulting field are
vector fields instead of scalar fields.

<P>
Note that the ``orientation'' transformation is applied to the import
spatial coordinates only, not the output vector.  For example, if the
<TT>field</TT> value represents a shaped vector field, and the <TT>script</TT>
proc is a rotation transformation, then the resulting vector field shape
will be rotated as compared to the original vector field, but the output
vectors themselves will still point in their original directions.  In such
cases one may wish to compose the <TT>Oxs_ScriptOrientVectorField</TT> with
a <A HREF="#item:ScriptVectorField"><TT>Oxs_ScriptVectorField</TT></A>
object to rotate the
output vectors as well.  This situation occurs also with the
<TT>Oxs_AffineOrientVectorField</TT> class.  See the
<A HREF="#item:AffineTransformVectorField"><TT>Oxs_AffineTransformVectorField</TT></A>
class documentation for an
example illustrating the composition of an object of that class with a
<A HREF="#item:AffineOrientVectorField"><TT>Oxs_AffineOrientVectorField</TT></A>
object.

<P>
<B>Example:</B> <TT><B>sample-vecreflect.mif</B></TT>.

<P>
<A NAME="AOVF"></A><A NAME="6259"></A></DD>
<DT><STRONG>Oxs_AffineOrientVectorField:<A NAME="item:AffineOrientVectorField"></A></STRONG></DT>
<DD>This class is analogous to the
<A HREF="#item:AffineOrientScalarField"><TT>Oxs_AffineOrientScalarField</TT></A>
class.
The Specify block has the form:
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_AffineOrientVectorField {</TT>
<DD><TT> field </TT><I>vector_field_spec</I>
<DD><TT> M
  {</TT> <I>matrix_entries</I><TT>&nbsp;</TT><I>...</I> <TT>}</TT>
<DD><TT> offset {</TT>
   <I>off<sub>x</sub></I><TT>&nbsp;</TT>
   <I>off<sub>y</sub></I><TT>&nbsp;</TT>
   <I>off<sub>z</sub></I> <TT>}</TT>
<DD><TT> inverse </TT><I>invert_flag</I>
<DD><TT> inverse_slack </TT><I>slack</I>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
The interpretation of the specify block and the affine transformation
is exactly the same as for the <TT>Oxs_AffineOrientScalarField</TT>
class, except the input <B>field</B> and the resulting field are
vector fields instead of scalar fields.

<P>
As explained in the 
<A HREF="#item:ScriptOrientVectorField"><TT>Oxs_ScriptOrientVectorField</TT></A>
documentation, the ``orientation'' transformation is applied to the
import spatial coordinates only, not the output vector.  If one wishes
to rotate the output vectors, then a
<A HREF="#item:AffineTransformVectorField"><TT>Oxs_AffineTransformVectorField</TT></A>
object may be applied with the opposite rotation.  See that section for
an example.

<P>
<B>Examples:</B> <TT><B>yoyo.mif</B></TT>, <TT><B>sample-vecrotate.mif</B></TT>.

<P>
<A NAME="ATVF"></A><A NAME="6273"></A></DD>
<DT><STRONG>Oxs_AffineTransformVectorField:<A NAME="item:AffineTransformVectorField"></A></STRONG></DT>
<DD>This class applies an affine transform to the output of a vector field.
It is similar to the
<A HREF="#item:AffineTransformScalarField"><TT>Oxs_AffineTransformScalarField</TT></A>
class, except
that in this case the affine transform is applied to a vector instead of
a scalar.  The Specify block has the form:
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_AffineTransformVectorField {</TT>
<DD><TT> field </TT><I>vector_field_spec</I>
<DD><TT> M
  {</TT> <I>matrix_entries</I><TT>&nbsp;</TT><I>...</I> <TT>}</TT>
<DD><TT> offset {</TT>
   <I>off<sub>x</sub></I><TT>&nbsp;</TT>
   <I>off<sub>y</sub></I><TT>&nbsp;</TT>
   <I>off<sub>z</sub></I> <TT>}</TT>
<DD><TT> inverse </TT><I>invert_flag</I>
<DD><TT> inverse_slack </TT><I>slack</I>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
Because the output from <B>field</B> is a 3-vector, the transform
defined by <B>M</B> and <B>offset</B> requires <TT>M</TT> to be a 
3x3 matrix and <TT>offset</TT> to be a 3-vector.
Thus, if <!-- MATH
 $\mbox{\boldmath $v$}(\mbox{\boldmath $x$})$
 -->
<B><B><I>v</I></B>
<!-- MATHEND
 
 -->
(<B><I>x</I></B>
<!-- MATHEND
 
 -->
)</B>
<!-- MATHEND
 
 -->
 represents the
vector field specified by the <B>field</B> value, then the resulting
vector field is
<!-- MATH
 $M.\mbox{\boldmath $v$}(\mbox{\boldmath $x$})+\textbf{off}$
 -->
<B><I>M</I>.<B><I>v</I></B>
<!-- MATHEND
 
 -->
(<B><I>x</I></B>
<!-- MATHEND
 
 -->
) + <B>off</B></B>
<!-- MATHEND
 
 -->
.

<P>
<TT>M</TT> is described by a list of from one to nine entries, in exactly
the same manner as for the
<A HREF="#item:AffineOrientVectorField"><TT>Oxs_AffineOrientVectorField</TT></A>
and
<A HREF="#item:AffineOrientScalarField"><TT>Oxs_AffineOrientScalarField</TT></A>
classes.  The
interpretation of <B>offset</B>, <B>inverse</B>, and
<B>inverse_slack</B> is also the same.  In particular, if
<I> invert_flag</I> is 1, then the resulting vector field is
<!-- MATH
 $M^{-1}.\left(\mbox{\boldmath $v$}(\mbox{\boldmath $x$})-\textbf{off}\right)$
 -->
<B><I>M</I><SUP>-1</SUP>.<IMG
 WIDTH="12" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img64.gif"
 ALT="$ \left(\vphantom{\mbox{\boldmath $v$}(\mbox{\boldmath $x$})-\textbf{off}}\right.$"><B><I>v</I></B>
<!-- MATHEND
 
 -->
(<B><I>x</I></B>
<!-- MATHEND
 
 -->
) - <B>off</B><IMG
 WIDTH="12" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img65.gif"
 ALT="$ \left.\vphantom{\mbox{\boldmath $v$}(\mbox{\boldmath $x$})-\textbf{off}}\right)$"></B>
<!-- MATHEND
 
 -->
.

<P>
The following example illustrates combining a
<TT>Oxs_AffineTransformVectorField</TT> with a
<A HREF="#item:AffineOrientVectorField"><TT>Oxs_AffineOrientVectorField</TT></A>
to completely rotate a vector field.
<BLOCKQUOTE><PRE>
Specify Oxs_BoxAtlas:atlas {
  xrange {-80e-9 80e-9}
  yrange {-80e-9 80e-9}
  zrange {0  40e-9}
}

proc Trap { x y z } {
     if {$y&lt;=$x &amp;&amp; $y&lt;=0.5} {return [list 0 1 0]}
     return [list 0 0 0]
}

Specify Oxs_ScriptVectorField:trap {
   script Trap
   atlas :atlas
}

Specify Oxs_AffineOrientVectorField:orient {
   field :trap
   M { 0 -1 0
       1  0 0
       0  0 1 }
   offset { -20e-9 0 0 }
   inverse 1
}

Specify Oxs_AffineTransformVectorField:rot {
   field :orient
   M { 0 -1 0
       1  0 0
       0  0 1 }
}

proc Threshold { vx vy vz } {
   set magsq [expr {$vx*$vx+$vy*$vy+$vz*$vz}]
   if {$magsq&gt;0} {return 8e5}
   return 0.0
}

Specify Oxs_ScriptScalarField:Ms {
  vector_fields :rot
  script Threshold
  script_args vectors  
}

Specify Oxs_TimeDriver {
 m0 :rot
 Ms :Ms
 stopping_dm_dt 0.01
 evolver :evolve
 mesh :mesh
}
</PRE>
</BLOCKQUOTE>
The base field here is given by the <TT>Oxs_ScriptVectorField:trap</TT>
object, which produces a vector field having a trapezoidal shape with
the non-zero vectors pointing parallel to the <B><I>y</I></B>
<!-- MATHEND
 
 -->
-axis.  The
<TT>:orient</TT> and <TT>:rot</TT> transformations rotate the shape and the
vectors counterclockwise 90 degrees.
Additionally, the <TT>offset</TT> option in <TT>:orient</TT> translates the
shape 20&nbsp;nm towards the left.  The original and transformed fields are
illustrated below.

<P>
<IMG ALT="Original field" SRC="../giffiles/trap-orig.gif">

<IMG ALT="Rotate field" SRC="../giffiles/trap-rot.gif">

<P>
<B>Example:</B> <TT><B>sample-vecrotate.mif</B></TT>.

<P>
<A NAME="MVF"></A><A NAME="6341"></A></DD>
<DT><STRONG>Oxs_MaskVectorField:<A NAME="item:MaskVectorField"></A></STRONG></DT>
<DD>Multiplies a vector field pointwise by a scalar vector field (the mask)
to produce a new vector field.  The Specify block has the form:
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_MaskVectorField {</TT>
<DD><TT> mask </TT><I>scalar_field_spec</I>
<DD><TT> field </TT><I>vector_field_spec</I>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
This functionality can be achieved, if in a somewhat more complicated
fashion, with the
<A HREF="#item:ScriptVectorField"><TT>Oxs_ScriptVectorField</TT></A>
class.  For example, given a scalar field <TT>:mask</TT> and a vector field
<TT>:vfield</TT>, this example using the <TT>Oxs_MaskVectorField</TT> class
<BLOCKQUOTE><PRE>
Specify Oxs_MaskVectorField {
   mask :mask
   field :vfield
}
</PRE>
</BLOCKQUOTE>
is equivalent to this example using the <TT>Oxs_ScriptVectorField</TT>
class
<BLOCKQUOTE><PRE>
proc MaskField { m vx vy vz } {
   return [list [expr {$m*$vx}] [expr {$m*$vy}] [expr {$m*$vz}]]
}

Specify Oxs_ScriptVectorField {
  script MaskField
  script_args {scalars vectors}
  scalar_fields { :mask }
  vector_fields { :vfield }
}
</PRE>
</BLOCKQUOTE>
Of course, the <TT>Oxs_ScriptVectorField</TT> approach is easily
generalized to much more complicated and arbitrary combinations of
scalar and vector fields.

<P>
<B>Example:</B> <TT><B>rotatecenterstage.mif</B></TT>.

<P>
<A NAME="IVF"></A><A NAME="6360"></A></DD>
<DT><STRONG>Oxs_ImageVectorField:<A NAME="item:ImageVectorField"></A></STRONG></DT>
<DD>This class creates a vector field using an image.  The Specify block has
the form
<BLOCKQUOTE><DL><DT>
<TT>Specify Oxs_ImageVectorField:</TT><I>name</I> <TT>{</TT>
<DD><TT>image </TT> <I>pic</I>
<DD><TT>multiplier </TT><I>mult</I>
<DD><TT>vx_multiplier </TT><I>xmult</I>
<DD><TT>vy_multiplier </TT><I>ymult</I>
<DD><TT>vz_multiplier </TT><I>zmult</I>
<DD><TT>vx_offset </TT><I>xoff</I>
<DD><TT>vy_offset </TT><I>yoff</I>
<DD><TT>vz_offset </TT><I>zoff</I>
<DD><TT>norm </TT> <I>norm_magnitude</I>
<DD><TT>viewplane </TT> <I>view</I>
<DD><TT>atlas </TT> <I>atlas_spec</I>
<DD><TT>xrange {</TT> <I>xmin</I><TT>&nbsp;</TT><I>xmax</I> <TT>}</TT>
<DD><TT>yrange {</TT> <I>ymin</I><TT>&nbsp;</TT><I>ymax</I> <TT>}</TT>
<DD><TT>zrange {</TT> <I>zmin</I><TT>&nbsp;</TT><I>zmax</I> <TT>}</TT>
<DD><TT>exterior </TT><I>ext_flag</I>
<DT><TT>}</TT></DL></BLOCKQUOTE><P>
The <B>image</B> is interpreted as a three-color map, yielding a
vector field where each (x,y,z) component is determined by the red,
green, and blue color components, respectively....

<P>
The <B>viewplane</B>, <B>atlas</B>,
<B>xrange/yrange/zrange</B>, and <B>exterior</B> are treated
the same as for the
<A HREF="#item:ImageScalarField"><TT>Oxs_ImageScalarField</TT> class</A>
<P>
<B>Examples:</B> <TT><B>NONE</B></TT>.

<P>
</DD>
</DL>

<P>

<H3><A NAME="SECTION00083700000000000000">
MIF Support Classes</A>
</H3>
<A NAME="LV"></A><DL>
<DD><A NAME="6375"></A></DD>
<DT><STRONG>Oxs_LabelValue:</STRONG></DT>
<DD>A convenience object that holds label + value
   pairs.  <TT>Oxs_LabelValue</TT> objects may be referenced via the
   standard <TT>attributes</TT> field in other Specify blocks, as in
   this example:
<BLOCKQUOTE>
<PRE>
Specify Oxs_LabelValue:probdata {
  alpha 0.5
  start_dm 0.01
}

Specify Oxs_EulerEvolve {
  attributes :probdata
}
</PRE>
</BLOCKQUOTE>
   The Specify block string for <TT>Oxs_LabelValue</TT> objects is an
   arbitrary Tcl list with an even number of elements.  The first
   element in each pair is interpreted as a label, the second as the
   value.  The <TT>attribute</TT> option causes this list to be dropped
   verbatim into the surrounding object.  This technique is most useful
   if the label + value pairs in the <TT>Oxs_LabelValue</TT> object are
   used in multiple Specify blocks, either inside the same MIF    file, or across several MIF files into which the
   <TT>Oxs_LabelValue</TT> block is imported using the <TT>ReadFile</TT> MIF    extension command.

<P>
<B>Examples:</B> The MIF files <TT><B>sample-rotate.mif</B></TT> and
   <TT><B>sample-reflect.mif</B></TT> use the <TT>Oxs_LabelValue</TT> object
   stored in the <TT><B>sample-attributes.tcl</B></TT> file.

<P>
</DD>
</DL>

<P>
Refer to the MIF&nbsp;2 documentation for details on the base format
specification.
<HR>
<!--Navigation Panel--><A NAME="tex2html1"
  HREF="http://math.nist.gov/oommf"><IMG ALT="OOMMF Home" BORDER="2" SRC="oommficon.gif"></A> 
<A NAME="tex2html357"
  HREF="Micromagnetic_Problem_Edito.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.gif"></A> 
<A NAME="tex2html353"
  HREF="OOMMF_eXtensible_Solver.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.gif"></A> 
<A NAME="tex2html349"
  HREF="OOMMF_eXtensible_Solver_Bat.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.gif"></A> 
<A NAME="tex2html360"
  HREF="userguide.html"><IMG ALIGN="BOTTOM" ALT="Contents" BORDER="0" SRC="contents.gif"></A> 
<A NAME="tex2html355"
  HREF="docindex.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index.gif"></A>
<BR>
<!--End of Navigation Panel-->
<BR><I><A HREF="Credits.html#sec:Credits">OOMMF Documentation Team</A><BR>September 29, 2017</I>
</BODY>
</HTML>
